{"ast":null,"code":"/**\n * @module ol/expr/cpu\n */\nimport { ColorType, LiteralExpression, Ops, overlapsType, parse, typeName } from './expression.js';\nimport { fromString, lchaToRgba, normalize, rgbaToLcha, toString, withAlpha } from '../color.js';\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\n\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: ''\n  };\n}\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\n\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, context);\n\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);\n  }\n\n  return compileExpression(expression, context);\n}\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n\n    return function () {\n      return expression.value;\n    };\n  }\n\n  const operator = expression.operator;\n\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce:\n      {\n        return compileAssertionExpression(expression, context);\n      }\n\n    case Ops.Get:\n    case Ops.Var:\n      {\n        return compileAccessorExpression(expression, context);\n      }\n\n    case Ops.Id:\n      {\n        return context => context.featureId;\n      }\n\n    case Ops.GeometryType:\n      {\n        return context => context.geometryType;\n      }\n\n    case Ops.Concat:\n      {\n        const args = expression.args.map(e => compileExpression(e, context));\n        return context => ''.concat(...args.map(arg => arg(context).toString()));\n      }\n\n    case Ops.Resolution:\n      {\n        return context => context.resolution;\n      }\n\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Between:\n    case Ops.In:\n    case Ops.Not:\n      {\n        return compileLogicalExpression(expression, context);\n      }\n\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return compileComparisonExpression(expression, context);\n      }\n\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt:\n      {\n        return compileNumericExpression(expression, context);\n      }\n\n    case Ops.Case:\n      {\n        return compileCaseExpression(expression, context);\n      }\n\n    case Ops.Match:\n      {\n        return compileMatchExpression(expression, context);\n      }\n\n    case Ops.Interpolate:\n      {\n        return compileInterpolateExpression(expression, context);\n      }\n\n    case Ops.ToString:\n      {\n        return compileConvertExpression(expression, context);\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported operator ${operator}`);\n      }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\n\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  switch (type) {\n    case Ops.Coalesce:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n\n            if (typeof value !== 'undefined' && value !== null) {\n              return value;\n            }\n          }\n\n          throw new Error('Expected one of the values to be non-null');\n        };\n      }\n\n    case Ops.Number:\n    case Ops.String:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n\n            if (typeof value === type) {\n              return value;\n            }\n          }\n\n          throw new Error(`Expected one of the values to be a ${type}`);\n        };\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported assertion operator ${type}`);\n      }\n  }\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\n\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression =\n  /** @type {LiteralExpression} */\n  expression.args[0];\n  const name =\n  /** @type {string} */\n  nameExpression.value;\n\n  switch (expression.operator) {\n    case Ops.Get:\n      {\n        return context => context.properties[name];\n      }\n\n    case Ops.Var:\n      {\n        return context => context.variables[name];\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported accessor operator ${expression.operator}`);\n      }\n  }\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\n\n\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n\n  switch (op) {\n    case Ops.Equal:\n      {\n        return context => left(context) === right(context);\n      }\n\n    case Ops.NotEqual:\n      {\n        return context => left(context) !== right(context);\n      }\n\n    case Ops.LessThan:\n      {\n        return context => left(context) < right(context);\n      }\n\n    case Ops.LessThanOrEqualTo:\n      {\n        return context => left(context) <= right(context);\n      }\n\n    case Ops.GreaterThan:\n      {\n        return context => left(context) > right(context);\n      }\n\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return context => left(context) >= right(context);\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported comparison operator ${op}`);\n      }\n  }\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\n\n\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  switch (op) {\n    case Ops.Any:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (args[i](context)) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n\n    case Ops.All:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (!args[i](context)) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n      }\n\n    case Ops.Between:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          const max = args[2](context);\n          return value >= min && value <= max;\n        };\n      }\n\n    case Ops.In:\n      {\n        return context => {\n          const value = args[0](context);\n\n          for (let i = 1; i < length; ++i) {\n            if (value === args[i](context)) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n\n    case Ops.Not:\n      {\n        return context => !args[0](context);\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported logical operator ${op}`);\n      }\n  }\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\n\n\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  switch (op) {\n    case Ops.Multiply:\n      {\n        return context => {\n          let value = 1;\n\n          for (let i = 0; i < length; ++i) {\n            value *= args[i](context);\n          }\n\n          return value;\n        };\n      }\n\n    case Ops.Divide:\n      {\n        return context => args[0](context) / args[1](context);\n      }\n\n    case Ops.Add:\n      {\n        return context => {\n          let value = 0;\n\n          for (let i = 0; i < length; ++i) {\n            value += args[i](context);\n          }\n\n          return value;\n        };\n      }\n\n    case Ops.Subtract:\n      {\n        return context => args[0](context) - args[1](context);\n      }\n\n    case Ops.Clamp:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n\n          if (value < min) {\n            return min;\n          }\n\n          const max = args[2](context);\n\n          if (value > max) {\n            return max;\n          }\n\n          return value;\n        };\n      }\n\n    case Ops.Mod:\n      {\n        return context => args[0](context) % args[1](context);\n      }\n\n    case Ops.Pow:\n      {\n        return context => Math.pow(args[0](context), args[1](context));\n      }\n\n    case Ops.Abs:\n      {\n        return context => Math.abs(args[0](context));\n      }\n\n    case Ops.Floor:\n      {\n        return context => Math.floor(args[0](context));\n      }\n\n    case Ops.Ceil:\n      {\n        return context => Math.ceil(args[0](context));\n      }\n\n    case Ops.Round:\n      {\n        return context => Math.round(args[0](context));\n      }\n\n    case Ops.Sin:\n      {\n        return context => Math.sin(args[0](context));\n      }\n\n    case Ops.Cos:\n      {\n        return context => Math.cos(args[0](context));\n      }\n\n    case Ops.Atan:\n      {\n        if (length === 2) {\n          return context => Math.atan2(args[0](context), args[1](context));\n        }\n\n        return context => Math.atan(args[0](context));\n      }\n\n    case Ops.Sqrt:\n      {\n        return context => Math.sqrt(args[0](context));\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported numeric operator ${op}`);\n      }\n  }\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\n\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  return context => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n\n    return args[length - 1](context);\n  };\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\n\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  return context => {\n    const value = args[0](context);\n\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n\n    return args[length - 1](context);\n  };\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\n\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  return context => {\n    const base = args[0](context);\n    const value = args[1](context);\n    let previousInput;\n    let previousOutput;\n\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n\n      if (isColor) {\n        output = withAlpha(output);\n      }\n\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n\n        if (isColor) {\n          return interpolateColor(base, value, previousInput, previousOutput, input, output);\n        }\n\n        return interpolateNumber(base, value, previousInput, previousOutput, input, output);\n      }\n\n      previousInput = input;\n      previousOutput = output;\n    }\n\n    return previousOutput;\n  };\n}\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\n\n\nfunction compileConvertExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n\n  switch (op) {\n    case Ops.ToString:\n      {\n        return context => {\n          const value = args[0](context);\n\n          if (expression.args[0].type === ColorType) {\n            return toString(value);\n          }\n\n          return value.toString();\n        };\n      }\n\n    default:\n      {\n        throw new Error(`Unsupported convert operator ${op}`);\n      }\n  }\n}\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\n\n\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n\n  if (delta === 0) {\n    return output1;\n  }\n\n  const along = value - input1;\n  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\n\n\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n\n  if (delta === 0) {\n    return rgba1;\n  }\n\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n\n  const lcha = [interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]), interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]), lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue), interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])];\n  return normalize(lchaToRgba(lcha));\n}","map":{"version":3,"names":["ColorType","LiteralExpression","Ops","overlapsType","parse","typeName","fromString","lchaToRgba","normalize","rgbaToLcha","toString","withAlpha","newEvaluationContext","variables","properties","resolution","NaN","featureId","geometryType","buildExpression","encoded","type","context","expression","expected","actual","Error","compileExpression","value","colorValue","operator","Number","String","Coalesce","compileAssertionExpression","Get","Var","compileAccessorExpression","Id","GeometryType","Concat","args","map","e","concat","arg","Resolution","Any","All","Between","In","Not","compileLogicalExpression","Equal","NotEqual","LessThan","LessThanOrEqualTo","GreaterThan","GreaterThanOrEqualTo","compileComparisonExpression","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","compileNumericExpression","Case","compileCaseExpression","Match","compileMatchExpression","Interpolate","compileInterpolateExpression","ToString","compileConvertExpression","length","Array","i","nameExpression","name","op","left","right","min","max","Math","pow","abs","floor","ceil","round","sin","cos","atan2","atan","sqrt","condition","base","previousInput","previousOutput","input","output","isColor","isArray","interpolateColor","interpolateNumber","input1","output1","input2","output2","delta","along","factor","rgba1","rgba2","lcha1","lcha2","deltaHue","lcha"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/expr/cpu.js"],"sourcesContent":["/**\n * @module ol/expr/cpu\n */\n\nimport {\n  ColorType,\n  LiteralExpression,\n  Ops,\n  overlapsType,\n  parse,\n  typeName,\n} from './expression.js';\nimport {\n  fromString,\n  lchaToRgba,\n  normalize,\n  rgbaToLcha,\n  toString,\n  withAlpha,\n} from '../color.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: '',\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, context);\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\n      `Expected expression to be of type ${expected}, got ${actual}`,\n    );\n  }\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce: {\n      return compileAssertionExpression(expression, context);\n    }\n    case Ops.Get:\n    case Ops.Var: {\n      return compileAccessorExpression(expression, context);\n    }\n    case Ops.Id: {\n      return (context) => context.featureId;\n    }\n    case Ops.GeometryType: {\n      return (context) => context.geometryType;\n    }\n    case Ops.Concat: {\n      const args = expression.args.map((e) => compileExpression(e, context));\n      return (context) =>\n        ''.concat(...args.map((arg) => arg(context).toString()));\n    }\n    case Ops.Resolution: {\n      return (context) => context.resolution;\n    }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Between:\n    case Ops.In:\n    case Ops.Not: {\n      return compileLogicalExpression(expression, context);\n    }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo: {\n      return compileComparisonExpression(expression, context);\n    }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt: {\n      return compileNumericExpression(expression, context);\n    }\n    case Ops.Case: {\n      return compileCaseExpression(expression, context);\n    }\n    case Ops.Match: {\n      return compileMatchExpression(expression, context);\n    }\n    case Ops.Interpolate: {\n      return compileInterpolateExpression(expression, context);\n    }\n    case Ops.ToString: {\n      return compileConvertExpression(expression, context);\n    }\n    default: {\n      throw new Error(`Unsupported operator ${operator}`);\n    }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Coalesce: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value !== 'undefined' && value !== null) {\n            return value;\n          }\n        }\n        throw new Error('Expected one of the values to be non-null');\n      };\n    }\n    case Ops.Number:\n    case Ops.String: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value === type) {\n            return value;\n          }\n        }\n        throw new Error(`Expected one of the values to be a ${type}`);\n      };\n    }\n    default: {\n      throw new Error(`Unsupported assertion operator ${type}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = /** @type {LiteralExpression} */ (expression.args[0]);\n  const name = /** @type {string} */ (nameExpression.value);\n  switch (expression.operator) {\n    case Ops.Get: {\n      return (context) => context.properties[name];\n    }\n    case Ops.Var: {\n      return (context) => context.variables[name];\n    }\n    default: {\n      throw new Error(`Unsupported accessor operator ${expression.operator}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal: {\n      return (context) => left(context) === right(context);\n    }\n    case Ops.NotEqual: {\n      return (context) => left(context) !== right(context);\n    }\n    case Ops.LessThan: {\n      return (context) => left(context) < right(context);\n    }\n    case Ops.LessThanOrEqualTo: {\n      return (context) => left(context) <= right(context);\n    }\n    case Ops.GreaterThan: {\n      return (context) => left(context) > right(context);\n    }\n    case Ops.GreaterThanOrEqualTo: {\n      return (context) => left(context) >= right(context);\n    }\n    default: {\n      throw new Error(`Unsupported comparison operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.All: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (!args[i](context)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    case Ops.Between: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        const max = args[2](context);\n        return value >= min && value <= max;\n      };\n    }\n    case Ops.In: {\n      return (context) => {\n        const value = args[0](context);\n        for (let i = 1; i < length; ++i) {\n          if (value === args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.Not: {\n      return (context) => !args[0](context);\n    }\n    default: {\n      throw new Error(`Unsupported logical operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply: {\n      return (context) => {\n        let value = 1;\n        for (let i = 0; i < length; ++i) {\n          value *= args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Divide: {\n      return (context) => args[0](context) / args[1](context);\n    }\n    case Ops.Add: {\n      return (context) => {\n        let value = 0;\n        for (let i = 0; i < length; ++i) {\n          value += args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Subtract: {\n      return (context) => args[0](context) - args[1](context);\n    }\n    case Ops.Clamp: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        if (value < min) {\n          return min;\n        }\n        const max = args[2](context);\n        if (value > max) {\n          return max;\n        }\n        return value;\n      };\n    }\n    case Ops.Mod: {\n      return (context) => args[0](context) % args[1](context);\n    }\n    case Ops.Pow: {\n      return (context) => Math.pow(args[0](context), args[1](context));\n    }\n    case Ops.Abs: {\n      return (context) => Math.abs(args[0](context));\n    }\n    case Ops.Floor: {\n      return (context) => Math.floor(args[0](context));\n    }\n    case Ops.Ceil: {\n      return (context) => Math.ceil(args[0](context));\n    }\n    case Ops.Round: {\n      return (context) => Math.round(args[0](context));\n    }\n    case Ops.Sin: {\n      return (context) => Math.sin(args[0](context));\n    }\n    case Ops.Cos: {\n      return (context) => Math.cos(args[0](context));\n    }\n    case Ops.Atan: {\n      if (length === 2) {\n        return (context) => Math.atan2(args[0](context), args[1](context));\n      }\n      return (context) => Math.atan(args[0](context));\n    }\n    case Ops.Sqrt: {\n      return (context) => Math.sqrt(args[0](context));\n    }\n    default: {\n      throw new Error(`Unsupported numeric operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const base = args[0](context);\n    const value = args[1](context);\n\n    let previousInput;\n    let previousOutput;\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n      if (isColor) {\n        output = withAlpha(output);\n      }\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n        if (isColor) {\n          return interpolateColor(\n            base,\n            value,\n            previousInput,\n            previousOutput,\n            input,\n            output,\n          );\n        }\n        return interpolateNumber(\n          base,\n          value,\n          previousInput,\n          previousOutput,\n          input,\n          output,\n        );\n      }\n      previousInput = input;\n      previousOutput = output;\n    }\n    return previousOutput;\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileConvertExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.ToString: {\n      return (context) => {\n        const value = args[0](context);\n        if (expression.args[0].type === ColorType) {\n          return toString(value);\n        }\n        return value.toString();\n      };\n    }\n    default: {\n      throw new Error(`Unsupported convert operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return output1;\n  }\n  const along = value - input1;\n  const factor =\n    base === 1\n      ? along / delta\n      : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return rgba1;\n  }\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n\n  const lcha = [\n    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),\n    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),\n    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),\n    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3]),\n  ];\n  return normalize(lchaToRgba(lcha));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}