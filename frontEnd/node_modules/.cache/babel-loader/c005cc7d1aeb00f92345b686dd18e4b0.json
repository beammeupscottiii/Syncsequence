{"ast":null,"code":"/**\n * @module ol/render/canvas/TextBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction from './Instruction.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { defaultFillStyle, defaultFont, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultPadding, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, registerFont } from '../canvas.js';\nimport { getUid } from '../../util.js';\nimport { intersects } from '../../extent.js';\nimport { lineChunk } from '../../geom/flat/linechunk.js';\nimport { matchingChunk } from '../../geom/flat/straightchunk.js';\n/**\n * @const\n * @type {{left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1}}\n */\n\nexport const TEXT_ALIGN = {\n  'left': 0,\n  'center': 0.5,\n  'right': 1,\n  'top': 0,\n  'middle': 0.5,\n  'hanging': 0.2,\n  'alphabetic': 0.8,\n  'ideographic': 0.8,\n  'bottom': 1\n};\n\nclass CanvasTextBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n\n    this.labels_ = null;\n    /**\n     * @private\n     * @type {string|Array<string>}\n     */\n\n    this.text_ = '';\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetY_ = 0;\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n\n    this.textRotateWithView_ = undefined;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textRotation_ = 0;\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n\n    this.textFillState_ = null;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = {};\n    this.fillStates[defaultFillStyle] = {\n      fillStyle: defaultFillStyle\n    };\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n\n    this.textStrokeState_ = null;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = {};\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n\n    this.textState_ =\n    /** @type {import(\"../canvas.js\").TextState} */\n    {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.textKey_ = '';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.fillKey_ = '';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.strokeKey_ = '';\n    /**\n     * @type {import('../../style/Style.js').DeclutterMode}\n     */\n\n    this.declutterMode_ = undefined;\n    /**\n     * Data shared with an image builder for combined decluttering.\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterImageWithText}\n     */\n\n    this.declutterImageWithText_ = undefined;\n  }\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  finish() {\n    const instructions = super.finish();\n    instructions.textStates = this.textStates;\n    instructions.fillStates = this.fillStates;\n    instructions.strokeStates = this.strokeStates;\n    return instructions;\n  }\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n\n\n  drawText(geometry, feature, index) {\n    const fillState = this.textFillState_;\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n\n    if (this.text_ === '' || !textState || !fillState && !strokeState) {\n      return;\n    }\n\n    const coordinates = this.coordinates;\n    let begin = coordinates.length;\n    const geometryType = geometry.getType();\n    let flatCoordinates = null;\n    let stride = geometry.getStride();\n\n    if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {\n      if (!intersects(this.maxExtent, geometry.getExtent())) {\n        return;\n      }\n\n      let ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n\n      if (geometryType == 'LineString') {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == 'MultiLineString') {\n        ends =\n        /** @type {import(\"../../geom/MultiLineString.js\").default} */\n        geometry.getEnds();\n      } else if (geometryType == 'Polygon') {\n        ends =\n        /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.getEnds().slice(0, 1);\n      } else if (geometryType == 'MultiPolygon') {\n        const endss =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getEndss();\n        ends = [];\n\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n\n      this.beginGeometry(geometry, feature, index);\n      const repeat = textState.repeat;\n      const textAlign = repeat ? undefined : textState.textAlign; // No `justify` support for line placement.\n\n      let flatOffset = 0;\n\n      for (let o = 0, oo = ends.length; o < oo; ++o) {\n        let chunks;\n\n        if (repeat) {\n          chunks = lineChunk(repeat * this.resolution, flatCoordinates, flatOffset, ends[o], stride);\n        } else {\n          chunks = [flatCoordinates.slice(flatOffset, ends[o])];\n        }\n\n        for (let c = 0, cc = chunks.length; c < cc; ++c) {\n          const chunk = chunks[c];\n          let chunkBegin = 0;\n          let chunkEnd = chunk.length;\n\n          if (textAlign == undefined) {\n            const range = matchingChunk(textState.maxAngle, chunk, 0, chunk.length, 2);\n            chunkBegin = range[0];\n            chunkEnd = range[1];\n          }\n\n          for (let i = chunkBegin; i < chunkEnd; i += stride) {\n            coordinates.push(chunk[i], chunk[i + 1]);\n          }\n\n          const end = coordinates.length;\n          flatOffset = ends[o];\n          this.drawChars_(begin, end);\n          begin = end;\n        }\n      }\n\n      this.endGeometry(feature);\n    } else {\n      let geometryWidths = textState.overflow ? null : [];\n\n      switch (geometryType) {\n        case 'Point':\n        case 'MultiPoint':\n          flatCoordinates =\n          /** @type {import(\"../../geom/MultiPoint.js\").default} */\n          geometry.getFlatCoordinates();\n          break;\n\n        case 'LineString':\n          flatCoordinates =\n          /** @type {import(\"../../geom/LineString.js\").default} */\n          geometry.getFlatMidpoint();\n          break;\n\n        case 'Circle':\n          flatCoordinates =\n          /** @type {import(\"../../geom/Circle.js\").default} */\n          geometry.getCenter();\n          break;\n\n        case 'MultiLineString':\n          flatCoordinates =\n          /** @type {import(\"../../geom/MultiLineString.js\").default} */\n          geometry.getFlatMidpoints();\n          stride = 2;\n          break;\n\n        case 'Polygon':\n          flatCoordinates =\n          /** @type {import(\"../../geom/Polygon.js\").default} */\n          geometry.getFlatInteriorPoint();\n\n          if (!textState.overflow) {\n            geometryWidths.push(flatCoordinates[2] / this.resolution);\n          }\n\n          stride = 3;\n          break;\n\n        case 'MultiPolygon':\n          const interiorPoints =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n          geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n\n          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (!textState.overflow) {\n              geometryWidths.push(interiorPoints[i + 2] / this.resolution);\n            }\n\n            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n          }\n\n          if (flatCoordinates.length === 0) {\n            return;\n          }\n\n          stride = 2;\n          break;\n\n        default:\n      }\n\n      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n      if (end === begin) {\n        return;\n      }\n\n      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {\n        let beg = begin / 2;\n        geometryWidths = geometryWidths.filter((w, i) => {\n          const keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];\n\n          if (!keep) {\n            --beg;\n          }\n\n          return keep;\n        });\n      }\n\n      this.saveTextStates_();\n\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill);\n        }\n\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n\n      this.beginGeometry(geometry, feature, index); // adjust padding for negative scale\n\n      let padding = textState.padding;\n\n      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {\n        let p0 = textState.padding[0];\n        let p1 = textState.padding[1];\n        let p2 = textState.padding[2];\n        let p3 = textState.padding[3];\n\n        if (textState.scale[0] < 0) {\n          p1 = -p1;\n          p3 = -p3;\n        }\n\n        if (textState.scale[1] < 0) {\n          p0 = -p0;\n          p2 = -p2;\n        }\n\n        padding = [p0, p1, p2, p3];\n      } // The image is unknown at this stage so we pass null; it will be computed at render time.\n      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at\n      // render time.\n\n\n      const pixelRatio = this.pixelRatio;\n      this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, this.declutterMode_, this.declutterImageWithText_, padding == defaultPadding ? defaultPadding : padding.map(function (p) {\n        return p * pixelRatio;\n      }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n      const scale = 1 / pixelRatio; // Set default fill for hit detection background\n\n      const currentFillStyle = this.state.fillStyle;\n\n      if (textState.backgroundFill) {\n        this.state.fillStyle = defaultFillStyle;\n        this.hitDetectionInstructions.push(this.createFill(this.state));\n      }\n\n      this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, this.declutterMode_, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_ ? defaultFillStyle : this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]); // Reset previous fill\n\n      if (textState.backgroundFill) {\n        this.state.fillStyle = currentFillStyle;\n        this.hitDetectionInstructions.push(this.createFill(this.state));\n      }\n\n      this.endGeometry(feature);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  saveTextStates_() {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const fillState = this.textFillState_;\n    const strokeKey = this.strokeKey_;\n\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n\n    const textKey = this.textKey_;\n\n    if (!(textKey in this.textStates)) {\n      this.textStates[textKey] = {\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        justify: textState.justify,\n        textBaseline: textState.textBaseline || defaultTextBaseline,\n        scale: textState.scale\n      };\n    }\n\n    const fillKey = this.fillKey_;\n\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = {\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n  }\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n\n\n  drawChars_(begin, end) {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const strokeKey = this.strokeKey_;\n    const textKey = this.textKey_;\n    const fillKey = this.fillKey_;\n    this.saveTextStates_();\n    const pixelRatio = this.pixelRatio;\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n    const offsetY = this.textOffsetY_ * pixelRatio;\n    const text = this.text_;\n    const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;\n    this.instructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1, this.declutterMode_]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey ? defaultFillStyle : fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1 / pixelRatio, this.declutterMode_]);\n  }\n  /**\n   * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n   * @param {Object} [sharedData] Shared data.\n   */\n\n\n  setTextStyle(textStyle, sharedData) {\n    let textState, fillState, strokeState;\n\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      const textFillStyle = textStyle.getFill();\n\n      if (!textFillStyle) {\n        fillState = null;\n        this.textFillState_ = fillState;\n      } else {\n        fillState = this.textFillState_;\n\n        if (!fillState) {\n          fillState =\n          /** @type {import(\"../canvas.js\").FillState} */\n          {};\n          this.textFillState_ = fillState;\n        }\n\n        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n      }\n\n      const textStrokeStyle = textStyle.getStroke();\n\n      if (!textStrokeStyle) {\n        strokeState = null;\n        this.textStrokeState_ = strokeState;\n      } else {\n        strokeState = this.textStrokeState_;\n\n        if (!strokeState) {\n          strokeState =\n          /** @type {import(\"../canvas.js\").StrokeState} */\n          {};\n          this.textStrokeState_ = strokeState;\n        }\n\n        const lineDash = textStrokeStyle.getLineDash();\n        const lineDashOffset = textStrokeStyle.getLineDashOffset();\n        const lineWidth = textStrokeStyle.getWidth();\n        const miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n\n      textState = this.textState_;\n      const font = textStyle.getFont() || defaultFont;\n      registerFont(font);\n      const textScale = textStyle.getScaleArray();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.repeat = textStyle.getRepeat();\n      textState.justify = textStyle.getJustify();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? [1, 1] : textScale;\n      const textOffsetX = textStyle.getOffsetX();\n      const textOffsetY = textStyle.getOffsetY();\n      const textRotateWithView = textStyle.getRotateWithView();\n      const textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.repeat || '?') + (textState.justify || '?') + (textState.textBaseline || '?');\n      this.fillKey_ = fillState && fillState.fillStyle ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';\n    }\n\n    this.declutterMode_ = textStyle.getDeclutterMode();\n    this.declutterImageWithText_ = sharedData;\n  }\n\n}\n\nexport default CanvasTextBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","asColorLike","defaultFillStyle","defaultFont","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultPadding","defaultStrokeStyle","defaultTextAlign","defaultTextBaseline","registerFont","getUid","intersects","lineChunk","matchingChunk","TEXT_ALIGN","CanvasTextBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","labels_","text_","textOffsetX_","textOffsetY_","textRotateWithView_","undefined","textRotation_","textFillState_","fillStates","fillStyle","textStrokeState_","strokeStates","textState_","textStates","textKey_","fillKey_","strokeKey_","declutterMode_","declutterImageWithText_","finish","instructions","drawText","geometry","feature","index","fillState","strokeState","textState","coordinates","begin","length","geometryType","getType","flatCoordinates","stride","getStride","placement","getExtent","ends","getFlatCoordinates","getEnds","slice","endss","getEndss","i","ii","push","beginGeometry","repeat","textAlign","flatOffset","o","oo","chunks","c","cc","chunk","chunkBegin","chunkEnd","range","maxAngle","end","drawChars_","endGeometry","geometryWidths","overflow","getFlatMidpoint","getCenter","getFlatMidpoints","getFlatInteriorPoint","interiorPoints","getFlatInteriorPoints","appendFlatPointCoordinates","beg","filter","w","keep","saveTextStates_","backgroundFill","backgroundStroke","setFillStrokeStyle","updateFillStyle","state","createFill","updateStrokeStyle","applyStroke","hitDetectionInstructions","createStroke","padding","scale","p0","p1","p2","p3","DRAW_IMAGE","NaN","map","p","currentFillStyle","strokeKey","strokeStyle","lineCap","lineDashOffset","lineWidth","lineJoin","miterLimit","lineDash","textKey","font","justify","textBaseline","fillKey","baseline","offsetY","text","strokeWidth","Math","abs","DRAW_CHARS","setTextStyle","textStyle","sharedData","textFillStyle","getFill","getColor","textStrokeStyle","getStroke","getLineDash","getLineDashOffset","getWidth","getMiterLimit","getLineCap","getLineJoin","getFont","textScale","getScaleArray","getOverflow","getMaxAngle","getPlacement","getTextAlign","getRepeat","getJustify","getTextBaseline","getBackgroundFill","getBackgroundStroke","getPadding","textOffsetX","getOffsetX","textOffsetY","getOffsetY","textRotateWithView","getRotateWithView","textRotation","getRotation","getText","join","getDeclutterMode"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/render/canvas/TextBuilder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/TextBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction from './Instruction.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {\n  defaultFillStyle,\n  defaultFont,\n  defaultLineCap,\n  defaultLineDash,\n  defaultLineDashOffset,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultPadding,\n  defaultStrokeStyle,\n  defaultTextAlign,\n  defaultTextBaseline,\n  registerFont,\n} from '../canvas.js';\nimport {getUid} from '../../util.js';\nimport {intersects} from '../../extent.js';\nimport {lineChunk} from '../../geom/flat/linechunk.js';\nimport {matchingChunk} from '../../geom/flat/straightchunk.js';\n/**\n * @const\n * @type {{left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1}}\n */\nexport const TEXT_ALIGN = {\n  'left': 0,\n  'center': 0.5,\n  'right': 1,\n  'top': 0,\n  'middle': 0.5,\n  'hanging': 0.2,\n  'alphabetic': 0.8,\n  'ideographic': 0.8,\n  'bottom': 1,\n};\n\nclass CanvasTextBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string|Array<string>}\n     */\n    this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = {};\n    this.fillStates[defaultFillStyle] = {fillStyle: defaultFillStyle};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    this.textState_ = /** @type {import(\"../canvas.js\").TextState} */ ({});\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n\n    /**\n     * @type {import('../../style/Style.js').DeclutterMode}\n     */\n    this.declutterMode_ = undefined;\n\n    /**\n     * Data shared with an image builder for combined decluttering.\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterImageWithText}\n     */\n    this.declutterImageWithText_ = undefined;\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    const instructions = super.finish();\n    instructions.textStates = this.textStates;\n    instructions.fillStates = this.fillStates;\n    instructions.strokeStates = this.strokeStates;\n    return instructions;\n  }\n\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n  drawText(geometry, feature, index) {\n    const fillState = this.textFillState_;\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {\n      return;\n    }\n\n    const coordinates = this.coordinates;\n    let begin = coordinates.length;\n\n    const geometryType = geometry.getType();\n    let flatCoordinates = null;\n    let stride = geometry.getStride();\n\n    if (\n      textState.placement === 'line' &&\n      (geometryType == 'LineString' ||\n        geometryType == 'MultiLineString' ||\n        geometryType == 'Polygon' ||\n        geometryType == 'MultiPolygon')\n    ) {\n      if (!intersects(this.maxExtent, geometry.getExtent())) {\n        return;\n      }\n      let ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      if (geometryType == 'LineString') {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == 'MultiLineString') {\n        ends = /** @type {import(\"../../geom/MultiLineString.js\").default} */ (\n          geometry\n        ).getEnds();\n      } else if (geometryType == 'Polygon') {\n        ends = /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry)\n          .getEnds()\n          .slice(0, 1);\n      } else if (geometryType == 'MultiPolygon') {\n        const endss =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getEndss();\n        ends = [];\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature, index);\n      const repeat = textState.repeat;\n      const textAlign = repeat ? undefined : textState.textAlign;\n      // No `justify` support for line placement.\n      let flatOffset = 0;\n      for (let o = 0, oo = ends.length; o < oo; ++o) {\n        let chunks;\n        if (repeat) {\n          chunks = lineChunk(\n            repeat * this.resolution,\n            flatCoordinates,\n            flatOffset,\n            ends[o],\n            stride,\n          );\n        } else {\n          chunks = [flatCoordinates.slice(flatOffset, ends[o])];\n        }\n        for (let c = 0, cc = chunks.length; c < cc; ++c) {\n          const chunk = chunks[c];\n          let chunkBegin = 0;\n          let chunkEnd = chunk.length;\n          if (textAlign == undefined) {\n            const range = matchingChunk(\n              textState.maxAngle,\n              chunk,\n              0,\n              chunk.length,\n              2,\n            );\n            chunkBegin = range[0];\n            chunkEnd = range[1];\n          }\n          for (let i = chunkBegin; i < chunkEnd; i += stride) {\n            coordinates.push(chunk[i], chunk[i + 1]);\n          }\n          const end = coordinates.length;\n          flatOffset = ends[o];\n          this.drawChars_(begin, end);\n          begin = end;\n        }\n      }\n      this.endGeometry(feature);\n    } else {\n      let geometryWidths = textState.overflow ? null : [];\n      switch (geometryType) {\n        case 'Point':\n        case 'MultiPoint':\n          flatCoordinates =\n            /** @type {import(\"../../geom/MultiPoint.js\").default} */ (\n              geometry\n            ).getFlatCoordinates();\n          break;\n        case 'LineString':\n          flatCoordinates =\n            /** @type {import(\"../../geom/LineString.js\").default} */ (\n              geometry\n            ).getFlatMidpoint();\n          break;\n        case 'Circle':\n          flatCoordinates =\n            /** @type {import(\"../../geom/Circle.js\").default} */ (\n              geometry\n            ).getCenter();\n          break;\n        case 'MultiLineString':\n          flatCoordinates =\n            /** @type {import(\"../../geom/MultiLineString.js\").default} */ (\n              geometry\n            ).getFlatMidpoints();\n          stride = 2;\n          break;\n        case 'Polygon':\n          flatCoordinates =\n            /** @type {import(\"../../geom/Polygon.js\").default} */ (\n              geometry\n            ).getFlatInteriorPoint();\n          if (!textState.overflow) {\n            geometryWidths.push(flatCoordinates[2] / this.resolution);\n          }\n          stride = 3;\n          break;\n        case 'MultiPolygon':\n          const interiorPoints =\n            /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n              geometry\n            ).getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (!textState.overflow) {\n              geometryWidths.push(interiorPoints[i + 2] / this.resolution);\n            }\n            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n          }\n          if (flatCoordinates.length === 0) {\n            return;\n          }\n          stride = 2;\n          break;\n        default:\n      }\n      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);\n      if (end === begin) {\n        return;\n      }\n      if (\n        geometryWidths &&\n        (end - begin) / 2 !== flatCoordinates.length / stride\n      ) {\n        let beg = begin / 2;\n        geometryWidths = geometryWidths.filter((w, i) => {\n          const keep =\n            coordinates[(beg + i) * 2] === flatCoordinates[i * stride] &&\n            coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];\n          if (!keep) {\n            --beg;\n          }\n          return keep;\n        });\n      }\n\n      this.saveTextStates_();\n\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(\n          textState.backgroundFill,\n          textState.backgroundStroke,\n        );\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill);\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n\n      this.beginGeometry(geometry, feature, index);\n\n      // adjust padding for negative scale\n      let padding = textState.padding;\n      if (\n        padding != defaultPadding &&\n        (textState.scale[0] < 0 || textState.scale[1] < 0)\n      ) {\n        let p0 = textState.padding[0];\n        let p1 = textState.padding[1];\n        let p2 = textState.padding[2];\n        let p3 = textState.padding[3];\n        if (textState.scale[0] < 0) {\n          p1 = -p1;\n          p3 = -p3;\n        }\n        if (textState.scale[1] < 0) {\n          p0 = -p0;\n          p2 = -p2;\n        }\n        padding = [p0, p1, p2, p3];\n      }\n\n      // The image is unknown at this stage so we pass null; it will be computed at render time.\n      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at\n      // render time.\n      const pixelRatio = this.pixelRatio;\n      this.instructions.push([\n        CanvasInstruction.DRAW_IMAGE,\n        begin,\n        end,\n        null,\n        NaN,\n        NaN,\n        NaN,\n        1,\n        0,\n        0,\n        this.textRotateWithView_,\n        this.textRotation_,\n        [1, 1],\n        NaN,\n        this.declutterMode_,\n        this.declutterImageWithText_,\n        padding == defaultPadding\n          ? defaultPadding\n          : padding.map(function (p) {\n              return p * pixelRatio;\n            }),\n        !!textState.backgroundFill,\n        !!textState.backgroundStroke,\n        this.text_,\n        this.textKey_,\n        this.strokeKey_,\n        this.fillKey_,\n        this.textOffsetX_,\n        this.textOffsetY_,\n        geometryWidths,\n      ]);\n      const scale = 1 / pixelRatio;\n      // Set default fill for hit detection background\n      const currentFillStyle = this.state.fillStyle;\n      if (textState.backgroundFill) {\n        this.state.fillStyle = defaultFillStyle;\n        this.hitDetectionInstructions.push(this.createFill(this.state));\n      }\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.DRAW_IMAGE,\n        begin,\n        end,\n        null,\n        NaN,\n        NaN,\n        NaN,\n        1,\n        0,\n        0,\n        this.textRotateWithView_,\n        this.textRotation_,\n        [scale, scale],\n        NaN,\n        this.declutterMode_,\n        this.declutterImageWithText_,\n        padding,\n        !!textState.backgroundFill,\n        !!textState.backgroundStroke,\n        this.text_,\n        this.textKey_,\n        this.strokeKey_,\n        this.fillKey_ ? defaultFillStyle : this.fillKey_,\n        this.textOffsetX_,\n        this.textOffsetY_,\n        geometryWidths,\n      ]);\n      // Reset previous fill\n      if (textState.backgroundFill) {\n        this.state.fillStyle = currentFillStyle;\n        this.hitDetectionInstructions.push(this.createFill(this.state));\n      }\n\n      this.endGeometry(feature);\n    }\n  }\n\n  /**\n   * @private\n   */\n  saveTextStates_() {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const fillState = this.textFillState_;\n\n    const strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash,\n        };\n      }\n    }\n    const textKey = this.textKey_;\n    if (!(textKey in this.textStates)) {\n      this.textStates[textKey] = {\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        justify: textState.justify,\n        textBaseline: textState.textBaseline || defaultTextBaseline,\n        scale: textState.scale,\n      };\n    }\n    const fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = {\n          fillStyle: fillState.fillStyle,\n        };\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  drawChars_(begin, end) {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n\n    const strokeKey = this.strokeKey_;\n    const textKey = this.textKey_;\n    const fillKey = this.fillKey_;\n    this.saveTextStates_();\n\n    const pixelRatio = this.pixelRatio;\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n\n    const offsetY = this.textOffsetY_ * pixelRatio;\n    const text = this.text_;\n    const strokeWidth = strokeState\n      ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2\n      : 0;\n\n    this.instructions.push([\n      CanvasInstruction.DRAW_CHARS,\n      begin,\n      end,\n      baseline,\n      textState.overflow,\n      fillKey,\n      textState.maxAngle,\n      pixelRatio,\n      offsetY,\n      strokeKey,\n      strokeWidth * pixelRatio,\n      text,\n      textKey,\n      1,\n      this.declutterMode_,\n    ]);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.DRAW_CHARS,\n      begin,\n      end,\n      baseline,\n      textState.overflow,\n      fillKey ? defaultFillStyle : fillKey,\n      textState.maxAngle,\n      pixelRatio,\n      offsetY,\n      strokeKey,\n      strokeWidth * pixelRatio,\n      text,\n      textKey,\n      1 / pixelRatio,\n      this.declutterMode_,\n    ]);\n  }\n\n  /**\n   * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n   * @param {Object} [sharedData] Shared data.\n   */\n  setTextStyle(textStyle, sharedData) {\n    let textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      const textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = null;\n        this.textFillState_ = fillState;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = /** @type {import(\"../canvas.js\").FillState} */ ({});\n          this.textFillState_ = fillState;\n        }\n        fillState.fillStyle = asColorLike(\n          textFillStyle.getColor() || defaultFillStyle,\n        );\n      }\n\n      const textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = null;\n        this.textStrokeState_ = strokeState;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = /** @type {import(\"../canvas.js\").StrokeState} */ ({});\n          this.textStrokeState_ = strokeState;\n        }\n        const lineDash = textStrokeStyle.getLineDash();\n        const lineDashOffset = textStrokeStyle.getLineDashOffset();\n        const lineWidth = textStrokeStyle.getWidth();\n        const miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset =\n          lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth =\n          lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit =\n          miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(\n          textStrokeStyle.getColor() || defaultStrokeStyle,\n        );\n      }\n\n      textState = this.textState_;\n      const font = textStyle.getFont() || defaultFont;\n      registerFont(font);\n      const textScale = textStyle.getScaleArray();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.repeat = textStyle.getRepeat();\n      textState.justify = textStyle.getJustify();\n      textState.textBaseline =\n        textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? [1, 1] : textScale;\n\n      const textOffsetX = textStyle.getOffsetX();\n      const textOffsetY = textStyle.getOffsetY();\n      const textRotateWithView = textStyle.getRotateWithView();\n      const textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ =\n        textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n\n      this.strokeKey_ = strokeState\n        ? (typeof strokeState.strokeStyle == 'string'\n            ? strokeState.strokeStyle\n            : getUid(strokeState.strokeStyle)) +\n          strokeState.lineCap +\n          strokeState.lineDashOffset +\n          '|' +\n          strokeState.lineWidth +\n          strokeState.lineJoin +\n          strokeState.miterLimit +\n          '[' +\n          strokeState.lineDash.join() +\n          ']'\n        : '';\n      this.textKey_ =\n        textState.font +\n        textState.scale +\n        (textState.textAlign || '?') +\n        (textState.repeat || '?') +\n        (textState.justify || '?') +\n        (textState.textBaseline || '?');\n      this.fillKey_ =\n        fillState && fillState.fillStyle\n          ? typeof fillState.fillStyle == 'string'\n            ? fillState.fillStyle\n            : '|' + getUid(fillState.fillStyle)\n          : '';\n    }\n    this.declutterMode_ = textStyle.getDeclutterMode();\n    this.declutterImageWithText_ = sharedData;\n  }\n}\n\nexport default CanvasTextBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}