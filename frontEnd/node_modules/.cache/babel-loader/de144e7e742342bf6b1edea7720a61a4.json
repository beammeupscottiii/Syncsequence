{"ast":null,"code":"/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\n\nclass CanvasBuilder extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super();\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n\n    this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n\n    this.state =\n    /** @type {import(\"../canvas.js\").FillStrokeState} */\n    {};\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n\n\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n\n\n  appendFlatPointCoordinates(flatCoordinates, stride) {\n    const extent = this.getBufferedMaxExtent();\n    const tmpCoord = this.tmpCoordinate_;\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n\n    return myEnd;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    let lastXCoord = flatCoordinates[offset];\n    let lastYCoord = flatCoordinates[offset + 1];\n    const nextCoord = this.tmpCoordinate_;\n    let skipped = true;\n    let i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n\n    return myEnd;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n\n\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n\n    return offset;\n  }\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   * @param {number} [index] Render order index.\n   */\n\n\n  drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {\n    this.beginGeometry(geometry, feature, index);\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const builderBegin = this.coordinates.length;\n    let flatCoordinates, builderEnd, builderEnds, builderEndss;\n    let offset;\n\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getOrientedFlatCoordinates();\n        builderEndss = [];\n        const endss =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getEndss();\n        offset = 0;\n\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          const myEnds = [];\n          offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n          builderEndss.push(myEnds);\n        }\n\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray, index]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray, index]);\n        break;\n\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates = type == 'Polygon' ?\n        /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */\n        geometry.getEnds(), stride, builderEnds);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray, index]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray, index]);\n        break;\n\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates, index]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates, index]);\n        break;\n\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates, index]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates, index]);\n        }\n\n        break;\n\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, undefined, index]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, undefined, index]);\n        break;\n\n      default:\n    }\n\n    this.endGeometry(feature);\n  }\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} index Render order index\n   */\n\n\n  beginGeometry(geometry, feature, index) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry, index];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry, index];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  finish() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  }\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type =\n      /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n\n\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillPatternScale = fillStyleColor && typeof fillStyleColor === 'object' && 'src' in fillStyleColor ? this.pixelRatio : 1;\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n\n\n  createFill(state) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align and scale it!\n      fillInstruction.push(state.fillPatternScale);\n    }\n\n    return fillInstruction;\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n\n\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n\n\n  createStroke(state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n\n\n  updateFillStyle(state, createFill) {\n    const fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n\n\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  endGeometry(feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        const width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  }\n\n}\n\nexport default CanvasBuilder;","map":{"version":3,"names":["CanvasInstruction","Relationship","VectorContext","asColorLike","buffer","clone","containsCoordinate","coordinateRelationship","defaultFillStyle","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","equals","reverseSubArray","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","CanvasBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","maxLineWidth","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","tmpCoordinate_","hitDetectionInstructions","state","applyPixelRatio","dashArray","map","dash","appendFlatPointCoordinates","flatCoordinates","stride","extent","getBufferedMaxExtent","tmpCoord","myEnd","length","i","ii","appendFlatLineCoordinates","offset","end","closed","skipFirst","lastXCoord","lastYCoord","nextCoord","skipped","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","builderEnds","builderEnd","push","drawCustom","geometry","feature","renderer","hitDetectionRenderer","index","beginGeometry","type","getType","getStride","builderBegin","builderEndss","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","getFlatCoordinates","getEnds","undefined","endGeometry","BEGIN_GEOMETRY","finish","reverseHitDetectionInstructions","reverse","n","instruction","begin","END_GEOMETRY","setFillStrokeStyle","fillStyle","strokeStyle","fillStyleColor","getColor","fillPatternScale","strokeStyleColor","strokeStyleLineCap","getLineCap","lineCap","strokeStyleLineDash","getLineDash","lineDash","slice","strokeStyleLineDashOffset","getLineDashOffset","lineDashOffset","strokeStyleLineJoin","getLineJoin","lineJoin","strokeStyleWidth","getWidth","lineWidth","strokeStyleMiterLimit","getMiterLimit","miterLimit","createFill","fillInstruction","SET_FILL_STYLE","applyStroke","createStroke","SET_STROKE_STYLE","updateFillStyle","currentFillStyle","call","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","width"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/render/canvas/Builder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {\n  buffer,\n  clone,\n  containsCoordinate,\n  coordinateRelationship,\n} from '../../extent.js';\nimport {\n  defaultFillStyle,\n  defaultLineCap,\n  defaultLineDash,\n  defaultLineDashOffset,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultStrokeStyle,\n} from '../canvas.js';\nimport {equals, reverseSubArray} from '../../array.js';\nimport {\n  inflateCoordinates,\n  inflateCoordinatesArray,\n  inflateMultiCoordinatesArray,\n} from '../../geom/flat/inflate.js';\n\nclass CanvasBuilder extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    this.tmpCoordinate_ = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1\n      ? dashArray\n      : dashArray.map(function (dash) {\n          return dash * pixelRatio;\n        });\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n  appendFlatPointCoordinates(flatCoordinates, stride) {\n    const extent = this.getBufferedMaxExtent();\n    const tmpCoord = this.tmpCoordinate_;\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  appendFlatLineCoordinates(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    closed,\n    skipFirst,\n  ) {\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    let lastXCoord = flatCoordinates[offset];\n    let lastYCoord = flatCoordinates[offset + 1];\n    const nextCoord = this.tmpCoordinate_;\n    let skipped = true;\n\n    let i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const builderEnd = this.appendFlatLineCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        false,\n        false,\n      );\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   * @param {number} [index] Render order index.\n   */\n  drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {\n    this.beginGeometry(geometry, feature, index);\n\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const builderBegin = this.coordinates.length;\n\n    let flatCoordinates, builderEnd, builderEnds, builderEndss;\n    let offset;\n\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getOrientedFlatCoordinates();\n        builderEndss = [];\n        const endss =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getEndss();\n        offset = 0;\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          const myEnds = [];\n          offset = this.drawCustomCoordinates_(\n            flatCoordinates,\n            offset,\n            endss[i],\n            stride,\n            myEnds,\n          );\n          builderEndss.push(myEnds);\n        }\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          renderer,\n          inflateMultiCoordinatesArray,\n          index,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateMultiCoordinatesArray,\n          index,\n        ]);\n        break;\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates =\n          type == 'Polygon'\n            ? /** @type {import(\"../../geom/Polygon.js\").default} */ (\n                geometry\n              ).getOrientedFlatCoordinates()\n            : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(\n          flatCoordinates,\n          0,\n          /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (\n            geometry\n          ).getEnds(),\n          stride,\n          builderEnds,\n        );\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          renderer,\n          inflateCoordinatesArray,\n          index,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinatesArray,\n          index,\n        ]);\n        break;\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(\n          flatCoordinates,\n          0,\n          flatCoordinates.length,\n          stride,\n          false,\n          false,\n        );\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n          inflateCoordinates,\n          index,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinates,\n          index,\n        ]);\n        break;\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            renderer,\n            inflateCoordinates,\n            index,\n          ]);\n          this.hitDetectionInstructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            hitDetectionRenderer || renderer,\n            inflateCoordinates,\n            index,\n          ]);\n        }\n        break;\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n          undefined,\n          index,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n          undefined,\n          index,\n        ]);\n        break;\n      default:\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} index Render order index\n   */\n  beginGeometry(geometry, feature, index) {\n    this.beginGeometryInstruction1_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      geometry,\n      index,\n    ];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      geometry,\n      index,\n    ];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates,\n    };\n  }\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillPatternScale =\n        fillStyleColor &&\n        typeof fillStyleColor === 'object' &&\n        'src' in fillStyleColor\n          ? this.pixelRatio\n          : 1;\n      state.fillStyle = asColorLike(\n        fillStyleColor ? fillStyleColor : defaultFillStyle,\n      );\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(\n        strokeStyleColor ? strokeStyleColor : defaultStrokeStyle,\n      );\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap =\n        strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash\n        ? strokeStyleLineDash.slice()\n        : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset\n        ? strokeStyleLineDashOffset\n        : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin =\n        strokeStyleLineJoin !== undefined\n          ? strokeStyleLineJoin\n          : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth =\n        strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit =\n        strokeStyleMiterLimit !== undefined\n          ? strokeStyleMiterLimit\n          : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n  createFill(state) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align and scale it!\n      fillInstruction.push(state.fillPatternScale);\n    }\n    return fillInstruction;\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  createStroke(state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth * this.pixelRatio,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      this.applyPixelRatio(state.lineDash),\n      state.lineDashOffset * this.pixelRatio,\n    ];\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n  updateFillStyle(state, createFill) {\n    const fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n    if (\n      state.currentStrokeStyle != strokeStyle ||\n      state.currentLineCap != lineCap ||\n      (lineDash != state.currentLineDash &&\n        !equals(state.currentLineDash, lineDash)) ||\n      state.currentLineDashOffset != lineDashOffset ||\n      state.currentLineJoin != lineJoin ||\n      state.currentLineWidth != lineWidth ||\n      state.currentMiterLimit != miterLimit\n    ) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  endGeometry(feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        const width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  }\n}\n\nexport default CanvasBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}