{"ast":null,"code":"/**\n * @module ol/Image\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport ImageState from './ImageState.js';\nimport { CREATE_IMAGE_BITMAP, IMAGE_DECODE } from './has.js';\nimport { listenOnce, unlistenByKey } from './events.js';\nimport { toPromise } from './functions.js';\n/**\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\n * @api\n */\n\n/**\n * @typedef {Object} ImageObject\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * For images that cover any extent and resolution (static images), the loader function should not accept\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\n * correct `extent`, `resolution` and `pixelRatio`.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\n * @api\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\n   * resolution will be assumed.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n\n    this.extent = extent;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @protected\n     * @type {number|Array<number>|undefined}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n\n    this.state = typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n    /**\n     * @private\n     * @type {import('./DataTile.js').ImageLike|null}\n     */\n\n    this.image_ = null;\n    /**\n     * @protected\n     * @type {import(\"./Image.js\").Loader}\n     */\n\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n  /**\n   * @protected\n   */\n\n\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n\n\n  getExtent() {\n    return this.extent;\n  }\n  /**\n   * @return {import('./DataTile.js').ImageLike} Image.\n   */\n\n\n  getImage() {\n    return this.image_;\n  }\n  /**\n   * @return {number} PixelRatio.\n   */\n\n\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n  /**\n   * @return {number|Array<number>} Resolution.\n   */\n\n\n  getResolution() {\n    return (\n      /** @type {number} */\n      this.resolution\n    );\n  }\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n\n\n  getState() {\n    return this.state;\n  }\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;\n        toPromise(() => this.loader(this.getExtent(), requestResolution, this.getPixelRatio())).then(image => {\n          if ('image' in image) {\n            this.image_ = image.image;\n          }\n\n          if ('extent' in image) {\n            this.extent = image.extent;\n          }\n\n          if ('resolution' in image) {\n            this.resolution = image.resolution;\n          }\n\n          if ('pixelRatio' in image) {\n            this.pixelRatio_ = image.pixelRatio;\n          }\n\n          if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {\n            this.image_ = image;\n          }\n\n          this.state = ImageState.LOADED;\n        }).catch(error => {\n          this.state = ImageState.ERROR;\n          console.error(error); // eslint-disable-line no-console\n        }).finally(() => this.changed());\n      }\n    }\n  }\n  /**\n   * @param {import('./DataTile.js').ImageLike} image The image.\n   */\n\n\n  setImage(image) {\n    this.image_ = image;\n  }\n  /**\n   * @param {number|Array<number>} resolution Resolution.\n   */\n\n\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n\n}\n/**\n * @param {import('./DataTile.js').ImageLike} image Image element.\n * @param {function():any} loadHandler Load callback function.\n * @param {function():any} errorHandler Error callback function.\n * @return {function():void} Callback to stop listening.\n */\n\n\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img =\n  /** @type {HTMLImageElement} */\n  image;\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n  const listenerKeys = [listenOnce(img, EventType.LOAD, function () {\n    loaded = true;\n\n    if (!decoding) {\n      loadHandler();\n    }\n  })];\n\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img.decode().then(function () {\n      if (listening) {\n        loadHandler();\n      }\n    }).catch(function (error) {\n      if (listening) {\n        if (loaded) {\n          loadHandler();\n        } else {\n          errorHandler();\n        }\n      }\n    });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n/**\n * Loads an image.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n * @api\n */\n\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n/**\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n */\n\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n\n  return image.src && IMAGE_DECODE ? new Promise((resolve, reject) => image.decode().then(() => resolve(image)).catch(e => image.complete && image.width ? resolve(image) : reject(e))) : load(image);\n}\n/**\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\n * the loaded image otherwise.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\n * @api\n */\n\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP ? image.decode().then(() => createImageBitmap(image)).catch(e => {\n    if (image.complete && image.width) {\n      return image;\n    }\n\n    throw e;\n  }) : decodeFallback(image);\n}\nexport default ImageWrapper;","map":{"version":3,"names":["EventTarget","EventType","ImageState","CREATE_IMAGE_BITMAP","IMAGE_DECODE","listenOnce","unlistenByKey","toPromise","ImageWrapper","constructor","extent","resolution","pixelRatio","stateOrLoader","pixelRatio_","state","IDLE","image_","loader","changed","dispatchEvent","CHANGE","getExtent","getImage","getPixelRatio","getResolution","getState","load","LOADING","requestResolution","Array","isArray","then","image","HTMLImageElement","ImageBitmap","HTMLCanvasElement","HTMLVideoElement","LOADED","catch","error","ERROR","console","finally","setImage","setResolution","listenImage","loadHandler","errorHandler","img","listening","decoding","loaded","listenerKeys","LOAD","src","decode","push","unlisten","forEach","Promise","resolve","reject","handleLoad","handleError","Error","removeEventListener","addEventListener","decodeFallback","e","complete","width","createImageBitmap"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/Image.js"],"sourcesContent":["/**\n * @module ol/Image\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport ImageState from './ImageState.js';\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport {toPromise} from './functions.js';\n\n/**\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\n * @api\n */\n\n/**\n * @typedef {Object} ImageObject\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * For images that cover any extent and resolution (static images), the loader function should not accept\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\n * correct `extent`, `resolution` and `pixelRatio`.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\n * @api\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\n   * resolution will be assumed.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|Array<number>|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state =\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n\n    /**\n     * @private\n     * @type {import('./DataTile.js').ImageLike|null}\n     */\n    this.image_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./Image.js\").Loader}\n     */\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @return {import('./DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number|Array<number>} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution)\n          ? resolution[0]\n          : resolution;\n        toPromise(() =>\n          this.loader(\n            this.getExtent(),\n            requestResolution,\n            this.getPixelRatio(),\n          ),\n        )\n          .then((image) => {\n            if ('image' in image) {\n              this.image_ = image.image;\n            }\n            if ('extent' in image) {\n              this.extent = image.extent;\n            }\n            if ('resolution' in image) {\n              this.resolution = image.resolution;\n            }\n            if ('pixelRatio' in image) {\n              this.pixelRatio_ = image.pixelRatio;\n            }\n            if (\n              image instanceof HTMLImageElement ||\n              image instanceof ImageBitmap ||\n              image instanceof HTMLCanvasElement ||\n              image instanceof HTMLVideoElement\n            ) {\n              this.image_ = image;\n            }\n            this.state = ImageState.LOADED;\n          })\n          .catch((error) => {\n            this.state = ImageState.ERROR;\n            console.error(error); // eslint-disable-line no-console\n          })\n          .finally(() => this.changed());\n      }\n    }\n  }\n\n  /**\n   * @param {import('./DataTile.js').ImageLike} image The image.\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * @param {number|Array<number>} resolution Resolution.\n   */\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n}\n\n/**\n * @param {import('./DataTile.js').ImageLike} image Image element.\n * @param {function():any} loadHandler Load callback function.\n * @param {function():any} errorHandler Error callback function.\n * @return {function():void} Callback to stop listening.\n */\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img = /** @type {HTMLImageElement} */ (image);\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n\n  const listenerKeys = [\n    listenOnce(img, EventType.LOAD, function () {\n      loaded = true;\n      if (!decoding) {\n        loadHandler();\n      }\n    }),\n  ];\n\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img\n      .decode()\n      .then(function () {\n        if (listening) {\n          loadHandler();\n        }\n      })\n      .catch(function (error) {\n        if (listening) {\n          if (loaded) {\n            loadHandler();\n          } else {\n            errorHandler();\n          }\n        }\n      });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n\n/**\n * Loads an image.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n * @api\n */\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n\n/**\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n */\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE\n    ? new Promise((resolve, reject) =>\n        image\n          .decode()\n          .then(() => resolve(image))\n          .catch((e) =>\n            image.complete && image.width ? resolve(image) : reject(e),\n          ),\n      )\n    : load(image);\n}\n\n/**\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\n * the loaded image otherwise.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\n * @api\n */\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP\n    ? image\n        .decode()\n        .then(() => createImageBitmap(image))\n        .catch((e) => {\n          if (image.complete && image.width) {\n            return image;\n          }\n          throw e;\n        })\n    : decodeFallback(image);\n}\n\nexport default ImageWrapper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}