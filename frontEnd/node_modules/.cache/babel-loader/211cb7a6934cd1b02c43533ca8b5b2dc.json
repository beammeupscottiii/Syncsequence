{"ast":null,"code":"/**\n * @module ol/render/canvas/ExecutorGroup\n */\nimport Executor from './Executor.js';\nimport { ascending } from '../../array.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\n\nexport const ALL = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\n\nexport const DECLUTTER = ['Image', 'Text'];\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\n\nexport const NON_DECLUTTER = ALL.filter(builderType => !DECLUTTER.includes(builderType));\n\nclass ExecutorGroup {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [renderBuffer] Optional rendering buffer.\n   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().\n   */\n  constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer, deferredRendering) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.renderBuffer_ = renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<string, import(\"./Executor\").default>>}\n     */\n\n    this.executorsByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.hitDetectionContext_ = null;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.hitDetectionTransform_ = createTransform();\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.renderedContext_ = null;\n    /**\n     * @type {Object<number, Array<import(\"./ZIndexContext.js\").default>>}\n     */\n\n    this.deferredZIndexContexts_ = {};\n    this.createExecutors_(allInstructions, deferredRendering);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n\n\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<string, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   * @param {boolean} deferredRendering Enable deferred rendering.\n   */\n\n\n  createExecutors_(allInstructions, deferredRendering) {\n    for (const zIndex in allInstructions) {\n      let executors = this.executorsByZIndex_[zIndex];\n\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n\n      const instructionByZindex = allInstructions[zIndex];\n\n      for (const builderType in instructionByZindex) {\n        const instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, deferredRendering);\n      }\n    }\n  }\n  /**\n   * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n\n\n  hasExecutors(executors) {\n    for (const zIndex in this.executorsByZIndex_) {\n      const candidates = this.executorsByZIndex_[zIndex];\n\n      for (let i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    const newContext = !this.hitDetectionContext_;\n\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize, undefined, {\n        willReadFrequently: true\n      });\n    }\n\n    const context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n\n    let hitExtent;\n\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    const indexes = getPixelIndexArray(hitTolerance);\n    let builderType;\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import('../../style/Style.js').DeclutterMode} declutterMode Declutter mode.\n     * @return {T|undefined} Callback result.\n     */\n\n    function featureCallback(feature, geometry, declutterMode) {\n      const imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n\n      for (let i = 0, ii = indexes.length; i < ii; i++) {\n        if (imageData[indexes[i]] > 0) {\n          if (!declutteredFeatures || declutterMode === 'none' || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {\n            const idx = (indexes[i] - 3) / 4;\n            const x = hitTolerance - idx % contextSize;\n            const y = hitTolerance - (idx / contextSize | 0);\n            const result = callback(feature, geometry, x * x + y * y);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n\n      return undefined;\n    }\n    /** @type {Array<number>} */\n\n\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n    let i, j, executors, executor, result;\n\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n\n      for (j = ALL.length - 1; j >= 0; --j) {\n        builderType = ALL[j];\n        executor = executors[builderType];\n\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>|null} Clip coordinates.\n   */\n\n\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n\n    if (!maxExtent) {\n      return null;\n    }\n\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n  /**\n   * @return {boolean} Is empty.\n   */\n\n\n  isEmpty() {\n    return isEmpty(this.executorsByZIndex_);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} targetContext Context.\n   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ALL}\n   * @param {import(\"rbush\").default|null} [declutterTree] Declutter tree.\n   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.\n   */\n\n\n  execute(targetContext, scaledCanvasSize, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n    builderTypes = builderTypes ? builderTypes : ALL;\n    const maxBuilderTypes = ALL.length;\n    let i, ii, j, jj, replays;\n\n    if (declutterTree) {\n      zs.reverse();\n    }\n\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        const builderType = builderTypes[j];\n        const replay = replays[builderType];\n\n        if (replay !== undefined) {\n          const zIndexContext = declutterTree === null ? undefined : replay.getZIndexContext();\n          const context = zIndexContext ? zIndexContext.getContext() : targetContext;\n          const requireClip = this.maxExtent_ && builderType !== 'Image' && builderType !== 'Text';\n\n          if (requireClip) {\n            context.save(); // setup clipping so that the parts of over-simplified geometries are not\n            // visible outside the current extent when panning\n\n            this.clip(context, transform);\n          }\n\n          if (!zIndexContext || builderType === 'Text' || builderType === 'Image') {\n            replay.execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree);\n          } else {\n            zIndexContext.pushFunction(context => replay.execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree));\n          }\n\n          if (requireClip) {\n            context.restore();\n          }\n\n          if (zIndexContext) {\n            zIndexContext.offset();\n            const index = zs[i] * maxBuilderTypes + j;\n\n            if (!this.deferredZIndexContexts_[index]) {\n              this.deferredZIndexContexts_[index] = [];\n            }\n\n            this.deferredZIndexContexts_[index].push(zIndexContext);\n          }\n        }\n      }\n    }\n\n    this.renderedContext_ = targetContext;\n  }\n\n  getDeferredZIndexContexts() {\n    return this.deferredZIndexContexts_;\n  }\n\n  getRenderedContext() {\n    return this.renderedContext_;\n  }\n\n  renderDeferred() {\n    const deferredZIndexContexts = this.deferredZIndexContexts_;\n    const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);\n\n    for (let i = 0, ii = zs.length; i < ii; ++i) {\n      deferredZIndexContexts[zs[i]].forEach(zIndexContext => {\n        zIndexContext.draw(this.renderedContext_); // FIXME Pass clip to replay for temporarily enabling clip\n\n        zIndexContext.clear();\n      });\n      deferredZIndexContexts[zs[i]].length = 0;\n    }\n  }\n\n}\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\n\n\nconst circlePixelIndexArrayCache = {};\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\n\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n\n  const size = radius * 2 + 1;\n  const maxDistanceSq = radius * radius;\n  const distances = new Array(maxDistanceSq + 1);\n\n  for (let i = 0; i <= radius; ++i) {\n    for (let j = 0; j <= radius; ++j) {\n      const distanceSq = i * i + j * j;\n\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n\n      let distance = distances[distanceSq];\n\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n\n  const pixelIndex = [];\n\n  for (let i = 0, ii = distances.length; i < ii; ++i) {\n    if (distances[i]) {\n      pixelIndex.push(...distances[i]);\n    }\n  }\n\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nexport default ExecutorGroup;","map":{"version":3,"names":["Executor","ascending","buffer","createEmpty","extendCoordinate","compose","composeTransform","create","createTransform","createCanvasContext2D","isEmpty","transform2D","ALL","DECLUTTER","NON_DECLUTTER","filter","builderType","includes","ExecutorGroup","constructor","maxExtent","resolution","pixelRatio","overlaps","allInstructions","renderBuffer","deferredRendering","maxExtent_","overlaps_","pixelRatio_","resolution_","renderBuffer_","executorsByZIndex_","hitDetectionContext_","hitDetectionTransform_","renderedContext_","deferredZIndexContexts_","createExecutors_","clip","context","transform","flatClipCoords","getClipCoords","beginPath","moveTo","lineTo","zIndex","executors","undefined","instructionByZindex","instructions","hasExecutors","candidates","i","ii","length","forEachFeatureAtCoordinate","coordinate","rotation","hitTolerance","callback","declutteredFeatures","Math","round","contextSize","newContext","willReadFrequently","canvas","width","height","clearRect","hitExtent","indexes","getPixelIndexArray","featureCallback","feature","geometry","declutterMode","imageData","getImageData","data","idx","x","y","result","zs","Object","keys","map","Number","sort","j","executor","zIndexKey","toString","executeHitDetection","minX","minY","maxX","maxY","execute","targetContext","scaledCanvasSize","viewRotation","snapToPixel","builderTypes","declutterTree","maxBuilderTypes","jj","replays","reverse","replay","zIndexContext","getZIndexContext","getContext","requireClip","save","pushFunction","restore","offset","index","push","getDeferredZIndexContexts","getRenderedContext","renderDeferred","deferredZIndexContexts","forEach","draw","clear","circlePixelIndexArrayCache","radius","size","maxDistanceSq","distances","Array","distanceSq","distance","pixelIndex"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/render/canvas/ExecutorGroup.js"],"sourcesContent":["/**\n * @module ol/render/canvas/ExecutorGroup\n */\n\nimport Executor from './Executor.js';\nimport {ascending} from '../../array.js';\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {isEmpty} from '../../obj.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nexport const ALL = [\n  'Polygon',\n  'Circle',\n  'LineString',\n  'Image',\n  'Text',\n  'Default',\n];\n\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nexport const DECLUTTER = ['Image', 'Text'];\n\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nexport const NON_DECLUTTER = ALL.filter(\n  (builderType) => !DECLUTTER.includes(builderType),\n);\n\nclass ExecutorGroup {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [renderBuffer] Optional rendering buffer.\n   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().\n   */\n  constructor(\n    maxExtent,\n    resolution,\n    pixelRatio,\n    overlaps,\n    allInstructions,\n    renderBuffer,\n    deferredRendering,\n  ) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<string, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.renderedContext_ = null;\n\n    /**\n     * @type {Object<number, Array<import(\"./ZIndexContext.js\").default>>}\n     */\n    this.deferredZIndexContexts_ = {};\n\n    this.createExecutors_(allInstructions, deferredRendering);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<string, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   * @param {boolean} deferredRendering Enable deferred rendering.\n   */\n  createExecutors_(allInstructions, deferredRendering) {\n    for (const zIndex in allInstructions) {\n      let executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      const instructionByZindex = allInstructions[zIndex];\n      for (const builderType in instructionByZindex) {\n        const instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(\n          this.resolution_,\n          this.pixelRatio_,\n          this.overlaps_,\n          instructions,\n          deferredRendering,\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  hasExecutors(executors) {\n    for (const zIndex in this.executorsByZIndex_) {\n      const candidates = this.executorsByZIndex_[zIndex];\n      for (let i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    resolution,\n    rotation,\n    hitTolerance,\n    callback,\n    declutteredFeatures,\n  ) {\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(\n      this.hitDetectionTransform_,\n      hitTolerance + 0.5,\n      hitTolerance + 0.5,\n      1 / resolution,\n      -1 / resolution,\n      -rotation,\n      -coordinate[0],\n      -coordinate[1],\n    );\n\n    const newContext = !this.hitDetectionContext_;\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(\n        contextSize,\n        contextSize,\n        undefined,\n        {willReadFrequently: true},\n      );\n    }\n    const context = this.hitDetectionContext_;\n\n    if (\n      context.canvas.width !== contextSize ||\n      context.canvas.height !== contextSize\n    ) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(\n        hitExtent,\n        resolution * (this.renderBuffer_ + hitTolerance),\n        hitExtent,\n      );\n    }\n\n    const indexes = getPixelIndexArray(hitTolerance);\n\n    let builderType;\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import('../../style/Style.js').DeclutterMode} declutterMode Declutter mode.\n     * @return {T|undefined} Callback result.\n     */\n    function featureCallback(feature, geometry, declutterMode) {\n      const imageData = context.getImageData(\n        0,\n        0,\n        contextSize,\n        contextSize,\n      ).data;\n      for (let i = 0, ii = indexes.length; i < ii; i++) {\n        if (imageData[indexes[i]] > 0) {\n          if (\n            !declutteredFeatures ||\n            declutterMode === 'none' ||\n            (builderType !== 'Image' && builderType !== 'Text') ||\n            declutteredFeatures.includes(feature)\n          ) {\n            const idx = (indexes[i] - 3) / 4;\n            const x = hitTolerance - (idx % contextSize);\n            const y = hitTolerance - ((idx / contextSize) | 0);\n            const result = callback(feature, geometry, x * x + y * y);\n            if (result) {\n              return result;\n            }\n          }\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n      return undefined;\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n\n    let i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ALL.length - 1; j >= 0; --j) {\n        builderType = ALL[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(\n            context,\n            transform,\n            rotation,\n            featureCallback,\n            hitExtent,\n          );\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>|null} Clip coordinates.\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.executorsByZIndex_);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} targetContext Context.\n   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ALL}\n   * @param {import(\"rbush\").default|null} [declutterTree] Declutter tree.\n   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.\n   */\n  execute(\n    targetContext,\n    scaledCanvasSize,\n    transform,\n    viewRotation,\n    snapToPixel,\n    builderTypes,\n    declutterTree,\n  ) {\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n\n    builderTypes = builderTypes ? builderTypes : ALL;\n    const maxBuilderTypes = ALL.length;\n    let i, ii, j, jj, replays;\n    if (declutterTree) {\n      zs.reverse();\n    }\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        const builderType = builderTypes[j];\n        const replay = replays[builderType];\n        if (replay !== undefined) {\n          const zIndexContext =\n            declutterTree === null ? undefined : replay.getZIndexContext();\n          const context = zIndexContext\n            ? zIndexContext.getContext()\n            : targetContext;\n          const requireClip =\n            this.maxExtent_ &&\n            builderType !== 'Image' &&\n            builderType !== 'Text';\n          if (requireClip) {\n            context.save();\n            // setup clipping so that the parts of over-simplified geometries are not\n            // visible outside the current extent when panning\n            this.clip(context, transform);\n          }\n          if (\n            !zIndexContext ||\n            builderType === 'Text' ||\n            builderType === 'Image'\n          ) {\n            replay.execute(\n              context,\n              scaledCanvasSize,\n              transform,\n              viewRotation,\n              snapToPixel,\n              declutterTree,\n            );\n          } else {\n            zIndexContext.pushFunction((context) =>\n              replay.execute(\n                context,\n                scaledCanvasSize,\n                transform,\n                viewRotation,\n                snapToPixel,\n                declutterTree,\n              ),\n            );\n          }\n          if (requireClip) {\n            context.restore();\n          }\n          if (zIndexContext) {\n            zIndexContext.offset();\n            const index = zs[i] * maxBuilderTypes + j;\n            if (!this.deferredZIndexContexts_[index]) {\n              this.deferredZIndexContexts_[index] = [];\n            }\n            this.deferredZIndexContexts_[index].push(zIndexContext);\n          }\n        }\n      }\n    }\n\n    this.renderedContext_ = targetContext;\n  }\n\n  getDeferredZIndexContexts() {\n    return this.deferredZIndexContexts_;\n  }\n\n  getRenderedContext() {\n    return this.renderedContext_;\n  }\n\n  renderDeferred() {\n    const deferredZIndexContexts = this.deferredZIndexContexts_;\n    const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);\n    for (let i = 0, ii = zs.length; i < ii; ++i) {\n      deferredZIndexContexts[zs[i]].forEach((zIndexContext) => {\n        zIndexContext.draw(this.renderedContext_); // FIXME Pass clip to replay for temporarily enabling clip\n        zIndexContext.clear();\n      });\n      deferredZIndexContexts[zs[i]].length = 0;\n    }\n  }\n}\n\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nconst circlePixelIndexArrayCache = {};\n\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n\n  const size = radius * 2 + 1;\n  const maxDistanceSq = radius * radius;\n  const distances = new Array(maxDistanceSq + 1);\n  for (let i = 0; i <= radius; ++i) {\n    for (let j = 0; j <= radius; ++j) {\n      const distanceSq = i * i + j * j;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      let distance = distances[distanceSq];\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n\n  const pixelIndex = [];\n  for (let i = 0, ii = distances.length; i < ii; ++i) {\n    if (distances[i]) {\n      pixelIndex.push(...distances[i]);\n    }\n  }\n\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\n\nexport default ExecutorGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}