{"ast":null,"code":"/**\n * @module ol/render/canvas/style\n */\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, computeGeometryType, newParsingContext } from '../../expr/expression.js';\nimport { buildExpression, newEvaluationContext } from '../../expr/cpu.js';\nimport { isEmpty } from '../../obj.js';\nimport { toSize } from '../../size.js';\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\n\nfunction always(context) {\n  return true;\n}\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\n\n\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n\n    if (parsingContext.geometryType) {\n      evaluationContext.geometryType = computeGeometryType(feature.getGeometry());\n    }\n\n    return evaluator(evaluationContext);\n  };\n}\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\n\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n\n  const evaluators = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n\n  const evaluationContext = newEvaluationContext();\n  /**\n   * @type {Array<Style>}\n   */\n\n  const styles = new Array(length);\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n\n    let nonNullCount = 0;\n\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\n\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n  /**\n   * @type {Array<CompiledRule>}\n   */\n\n  const compiledRules = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter = 'filter' in rule ? buildExpression(rule.filter, BooleanType, context) : always;\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n\n    let styles;\n\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n\n    compiledRules[i] = {\n      filter,\n      styles\n    };\n  }\n\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n    let someMatched = false;\n\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n\n      someMatched = true;\n\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n\n        if (!style) {\n          continue;\n        }\n\n        styles.push(style);\n      }\n    }\n\n    return styles;\n  };\n}\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\n\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n\n  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));\n  }\n\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n\n      if (fill) {\n        empty = false;\n      }\n\n      style.setFill(fill);\n    }\n\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n\n      if (stroke) {\n        empty = false;\n      }\n\n      style.setStroke(stroke);\n    }\n\n    if (evaluateText) {\n      const text = evaluateText(context);\n\n      if (text) {\n        empty = false;\n      }\n\n      style.setText(text);\n    }\n\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n\n      if (image) {\n        empty = false;\n      }\n\n      style.setImage(image);\n    }\n\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n\n    if (empty) {\n      return null;\n    }\n\n    return style;\n  };\n}\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\n\nfunction buildFill(flatStyle, prefix, context) {\n  let evaluateColor;\n\n  if (prefix + 'fill-pattern-src' in flatStyle) {\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\n  } else {\n    evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);\n  }\n\n  if (!evaluateColor) {\n    return null;\n  }\n\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n\n    if (color === 'none') {\n      return null;\n    }\n\n    fill.setColor(color);\n    return fill;\n  };\n}\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\n\n\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);\n\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n\n  const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);\n  const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);\n  const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);\n  const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);\n  const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n\n      if (color === 'none') {\n        return null;\n      }\n\n      stroke.setColor(color);\n    }\n\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n\n      stroke.setLineCap(lineCap);\n    }\n\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n\n      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n\n      stroke.setLineJoin(lineJoin);\n    }\n\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n\n    return stroke;\n  };\n}\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\n\n\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-'; // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n\n  if (!evaluateValue) {\n    return null;\n  }\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n  const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);\n  const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);\n  const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);\n  const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);\n  const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n  const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);\n  const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);\n  const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context); // The following properties are not currently settable\n\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const text = new Text({\n    declutterMode\n  });\n  return function (context) {\n    text.setText(evaluateValue(context));\n\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n\n      text.setPlacement(placement);\n    }\n\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n\n      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {\n        throw new Error('Expected left, right, center, start, or end for text-align');\n      }\n\n      text.setTextAlign(textAlign);\n    }\n\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n\n      text.setJustify(justify);\n    }\n\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n\n      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {\n        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');\n      }\n\n      text.setTextBaseline(textBaseline);\n    }\n\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n\n    return text;\n  };\n}\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\n\n\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n\n  return null;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\n\n\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-'; // required property\n\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName); // settable properties\n\n  const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context); // the remaining symbolizer properties are not currently settable\n\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');\n  const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n\n    return icon;\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\n\n\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-'; // required property\n\n  const pointsName = prefix + 'points';\n  const radiusName = prefix + 'radius';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n  const radius = requireNumber(flatStyle[radiusName], radiusName); // settable properties\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context); // the remaining properties are not currently settable\n\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius2,\n    angle,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n\n    return shape;\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\n\n\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-'; // settable properties\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context); // the remaining properties are not currently settable\n\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const circle = new Circle({\n    radius: 5,\n    // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n\n    return circle;\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\n\n\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\n\n\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\nfunction patternEvaluator(flatStyle, prefix, context) {\n  const srcEvaluator = stringEvaluator(flatStyle, prefix + 'pattern-src', context);\n  const offsetEvaluator = sizeEvaluator(flatStyle, prefix + 'pattern-offset', context);\n  const patternSizeEvaluator = sizeEvaluator(flatStyle, prefix + 'pattern-size', context);\n  const colorEvaluator = colorLikeEvaluator(flatStyle, prefix + 'color', context);\n  return function (context) {\n    return {\n      src: srcEvaluator(context),\n      offset: offsetEvaluator && offsetEvaluator(context),\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\n      color: colorEvaluator && colorEvaluator(context)\n    };\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\n\n\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n\n    return value;\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\n\n\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], ColorType | StringType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\n\n\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\n\n\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n\n    return array;\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\n */\n\n\nfunction sizeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireSize(evaluator(context), name);\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\n\n\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType | NumberType, context);\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\n\n\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n\n  if (value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n\n  return value;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\n\n\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n\n  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n\n  return encoded;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\n\n\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n\n  return encoded;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\n\n\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {\n    throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);\n  }\n\n  return encoded;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\n\n\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n\n  return encoded;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\n\n\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  return requireNumberArray(encoded, property);\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\n */\n\n\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n\n  return encoded;\n}\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\n\n\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n\n  if (encoded === undefined) {\n    return undefined;\n  }\n\n  return requireColorLike(encoded, property);\n}\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\n\n\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n\n  const length = value.length;\n\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n\n  return value;\n}\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\n\n\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n\n  return value;\n}\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\n\n\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n\n  return value;\n}\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\n\n\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n\n  return array;\n}\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} A number or an array of two numbers.\n */\n\n\nfunction requireSize(value, property) {\n  const size = requireNumberArray(value, property);\n\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n\n  return size;\n}\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\n\n\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  return requireSize(value, property);\n}","map":{"version":3,"names":["Circle","Fill","Icon","RegularShape","Stroke","Style","Text","BooleanType","ColorType","NumberArrayType","NumberType","StringType","computeGeometryType","newParsingContext","buildExpression","newEvaluationContext","isEmpty","toSize","always","context","rulesToStyleFunction","rules","parsingContext","evaluator","buildRuleSet","evaluationContext","feature","resolution","properties","getPropertiesInternal","featureId","id","getId","undefined","geometryType","getGeometry","flatStylesToStyleFunction","flatStyles","length","evaluators","Array","i","buildStyle","styles","nonNullCount","style","compiledRules","rule","filter","isArray","styleLength","j","someMatched","filterEvaluator","else","styleEvaluator","push","flatStyle","evaluateFill","buildFill","evaluateStroke","buildStroke","evaluateText","buildText","evaluateImage","buildImage","evaluateZIndex","numberEvaluator","Error","JSON","stringify","empty","fill","setFill","stroke","setStroke","text","setText","image","setImage","setZIndex","prefix","evaluateColor","patternEvaluator","colorLikeEvaluator","color","setColor","evaluateWidth","evaluateLineCap","stringEvaluator","evaluateLineJoin","evaluateLineDash","numberArrayEvaluator","evaluateLineDashOffset","evaluateMiterLimit","setWidth","lineCap","setLineCap","lineJoin","setLineJoin","setLineDash","setLineDashOffset","setMiterLimit","evaluateValue","evaluateBackgroundFill","evaluateBackgroundStroke","evaluateFont","evaluateMaxAngle","evaluateOffsetX","evaluateOffsetY","evaluateOverflow","booleanEvaluator","evaluatePlacement","evaluateRepeat","evaluateScale","sizeLikeEvaluator","evaluateRotateWithView","evaluateRotation","evaluateAlign","evaluateJustify","evaluateBaseline","evaluatePadding","declutterMode","optionalDeclutterMode","setBackgroundFill","setBackgroundStroke","setFont","setMaxAngle","setOffsetX","setOffsetY","setOverflow","placement","setPlacement","setRepeat","setScale","setRotateWithView","setRotation","textAlign","setTextAlign","justify","setJustify","textBaseline","setTextBaseline","setPadding","buildIcon","buildShape","buildCircle","srcName","src","requireString","evaluateAnchor","coordinateEvaluator","evaluateOpacity","evaluateDisplacement","anchorOrigin","optionalIconOrigin","anchorXUnits","optionalIconAnchorUnits","anchorYUnits","optionalColorLike","crossOrigin","optionalString","offset","optionalNumberArray","offsetOrigin","width","optionalNumber","height","size","optionalSize","icon","setOpacity","setDisplacement","setAnchor","pointsName","radiusName","points","requireNumber","radius","radius2","angle","shape","evaluateRadius","circle","setRadius","name","srcEvaluator","offsetEvaluator","sizeEvaluator","patternSizeEvaluator","colorEvaluator","value","requireColorLike","requireNumberArray","array","requireSize","requireSizeLike","property","encoded"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/render/canvas/style.js"],"sourcesContent":["/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  computeGeometryType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {isEmpty} from '../../obj.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    if (parsingContext.geometryType) {\n      evaluationContext.geometryType = computeGeometryType(\n        feature.getGeometry(),\n      );\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter =\n      'filter' in rule\n        ? buildExpression(rule.filter, BooleanType, context)\n        : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n\n    compiledRules[i] = {filter, styles};\n  }\n\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n\n  if (\n    !evaluateFill &&\n    !evaluateStroke &&\n    !evaluateText &&\n    !evaluateImage &&\n    !isEmpty(flatStyle)\n  ) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error(\n      'No fill, stroke, point, or text symbolizer properties in style: ' +\n        JSON.stringify(flatStyle),\n    );\n  }\n\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  let evaluateColor;\n  if (prefix + 'fill-pattern-src' in flatStyle) {\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\n  } else {\n    evaluateColor = colorLikeEvaluator(\n      flatStyle,\n      prefix + 'fill-color',\n      context,\n    );\n  }\n  if (!evaluateColor) {\n    return null;\n  }\n\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-width',\n    context,\n  );\n\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'stroke-color',\n    context,\n  );\n\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n\n  const evaluateLineCap = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-cap',\n    context,\n  );\n\n  const evaluateLineJoin = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-join',\n    context,\n  );\n\n  const evaluateLineDash = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash',\n    context,\n  );\n\n  const evaluateLineDashOffset = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash-offset',\n    context,\n  );\n\n  const evaluateMiterLimit = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-miter-limit',\n    context,\n  );\n\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (\n        lineJoin !== 'bevel' &&\n        lineJoin !== 'round' &&\n        lineJoin !== 'miter'\n      ) {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n\n  const evaluateBackgroundFill = buildFill(\n    flatStyle,\n    prefix + 'background-',\n    context,\n  );\n\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n\n  const evaluateBackgroundStroke = buildStroke(\n    flatStyle,\n    prefix + 'background-',\n    context,\n  );\n\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n\n  const evaluateMaxAngle = numberEvaluator(\n    flatStyle,\n    prefix + 'max-angle',\n    context,\n  );\n\n  const evaluateOffsetX = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-x',\n    context,\n  );\n\n  const evaluateOffsetY = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-y',\n    context,\n  );\n\n  const evaluateOverflow = booleanEvaluator(\n    flatStyle,\n    prefix + 'overflow',\n    context,\n  );\n\n  const evaluatePlacement = stringEvaluator(\n    flatStyle,\n    prefix + 'placement',\n    context,\n  );\n\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n\n  const evaluateJustify = stringEvaluator(\n    flatStyle,\n    prefix + 'justify',\n    context,\n  );\n\n  const evaluateBaseline = stringEvaluator(\n    flatStyle,\n    prefix + 'baseline',\n    context,\n  );\n\n  const evaluatePadding = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'padding',\n    context,\n  );\n\n  // The following properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const text = new Text({declutterMode});\n\n  return function (context) {\n    text.setText(evaluateValue(context));\n\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (\n        textAlign !== 'left' &&\n        textAlign !== 'center' &&\n        textAlign !== 'right' &&\n        textAlign !== 'end' &&\n        textAlign !== 'start'\n      ) {\n        throw new Error(\n          'Expected left, right, center, start, or end for text-align',\n        );\n      }\n      text.setTextAlign(textAlign);\n    }\n\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (\n        textBaseline !== 'bottom' &&\n        textBaseline !== 'top' &&\n        textBaseline !== 'middle' &&\n        textBaseline !== 'alphabetic' &&\n        textBaseline !== 'hanging'\n      ) {\n        throw new Error(\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline',\n        );\n      }\n      text.setTextBaseline(textBaseline);\n    }\n\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(\n    flatStyle,\n    prefix + 'anchor',\n    context,\n  );\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateOpacity = numberEvaluator(\n    flatStyle,\n    prefix + 'opacity',\n    context,\n  );\n\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context,\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-x-units',\n  );\n  const anchorYUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-y-units',\n  );\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const radiusName = prefix + 'radius';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n  const radius = requireNumber(flatStyle[radiusName], radiusName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context,\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  // the remaining properties are not currently settable\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius2,\n    angle,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context,\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const circle = new Circle({\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\nfunction patternEvaluator(flatStyle, prefix, context) {\n  const srcEvaluator = stringEvaluator(\n    flatStyle,\n    prefix + 'pattern-src',\n    context,\n  );\n  const offsetEvaluator = sizeEvaluator(\n    flatStyle,\n    prefix + 'pattern-offset',\n    context,\n  );\n  const patternSizeEvaluator = sizeEvaluator(\n    flatStyle,\n    prefix + 'pattern-size',\n    context,\n  );\n  const colorEvaluator = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'color',\n    context,\n  );\n  return function (context) {\n    return {\n      src: srcEvaluator(context),\n      offset: offsetEvaluator && offsetEvaluator(context),\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\n      color: colorEvaluator && colorEvaluator(context),\n    };\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    ColorType | StringType,\n    context,\n  );\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\n */\nfunction sizeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireSize(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    NumberArrayType | NumberType,\n    context,\n  );\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (\n    encoded.length !== 2 ||\n    typeof encoded[0] !== 'number' ||\n    typeof encoded[1] !== 'number'\n  ) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (\n    encoded !== 'bottom-left' &&\n    encoded !== 'bottom-right' &&\n    encoded !== 'top-left' &&\n    encoded !== 'top-right'\n  ) {\n    throw new Error(\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`,\n    );\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} A number or an array of two numbers.\n */\nfunction requireSize(value, property) {\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  return requireSize(value, property);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}