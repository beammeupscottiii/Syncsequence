{"ast":null,"code":"/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection, getWidth, wrapAndSliceX } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\n\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {\n    super(tileCoord, TileState.IDLE, options);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n\n    this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n\n    this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.sourceZ_ = 0;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : undefined;\n    const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor((sourceExtent[0] - sourceProjExtent[0]) / worldWidth);\n      }\n\n      const sourceExtents = wrapAndSliceX(sourceExtent.slice(), sourceProj, true);\n      sourceExtents.forEach(extent => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(extent, this.sourceZ_);\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({\n                tile,\n                offset\n              });\n            }\n          }\n        }\n\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  getImage() {\n    return this.canvas_;\n  }\n  /**\n   * @private\n   */\n\n\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(source => {\n      const tile = source.tile;\n\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage()\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n      this.state = TileState.LOADED;\n    }\n\n    this.changed();\n  }\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      let leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(_ref => {\n        let {\n          tile\n        } = _ref;\n        const state = tile.getState();\n\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n          const sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n            const state = tile.getState();\n\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (_ref2, i, arr) {\n          let {\n            tile\n          } = _ref2;\n          const state = tile.getState();\n\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n  /**\n   * Remove from the cache due to expiry\n   */\n\n\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n\n    super.release();\n  }\n\n}\n\nexport default ReprojTile;","map":{"version":3,"names":["ERROR_THRESHOLD","EventType","Tile","TileState","Triangulation","calculateSourceExtentResolution","canvasPool","render","renderReprojected","clamp","getArea","getIntersection","getWidth","wrapAndSliceX","listen","unlistenByKey","releaseCanvas","ReprojTile","constructor","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","errorThreshold","renderEdges","options","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","clipExtent_","canWrapX","getExtent","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","Math","floor","sourceExtents","slice","forEach","extent","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","offset","push","getImage","reproject_","sources","source","getState","LOADED","clipExtent","image","ERROR","z","size","getTileSize","width","height","interpolate","changed","load","LOADING","leftToLoad","sourceListenKey","CHANGE","e","unlistenSources_","setTimeout","bind","i","arr","release","getContext"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this,\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}