{"ast":null,"code":"/**\n * @module ol/color\n */\nimport lchuv from 'color-space/lchuv.js';\nimport parseRgba from 'color-rgba';\nimport rgb from 'color-space/rgb.js';\nimport xyz from 'color-space/xyz.js';\nimport { clamp } from './math.js';\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\n\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n\n  return toString(color);\n}\n/**\n * @type {number}\n */\n\nconst MAX_CACHE_SIZE = 1024;\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\n\nconst cache = {};\n/**\n * @type {number}\n */\n\nlet cacheSize = 0;\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\n\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\n\nexport function rgbaToLcha(color) {\n  const output = xyz.lchuv(rgb.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\n\nexport function lchaToRgba(color) {\n  const output = xyz.rgb(lchuv.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\n\nexport function fromString(s) {\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n\n  const color = parseRgba(s);\n\n  if (color.length !== 4) {\n    throw new Error('Failed to parse \"' + s + '\" as color');\n  }\n\n  for (const c of color) {\n    if (isNaN(c)) {\n      throw new Error('Failed to parse \"' + s + '\" as color');\n    }\n  }\n\n  normalize(color);\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\n\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n\n  return fromString(color);\n}\n/**\n * Exported for the tests.\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\n\nexport function normalize(color) {\n  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);\n  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);\n  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\n\nexport function toString(color) {\n  let r = color[0];\n\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n\n  let g = color[1];\n\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n\n  let b = color[2];\n\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\n\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}","map":{"version":3,"names":["lchuv","parseRgba","rgb","xyz","clamp","asString","color","toString","MAX_CACHE_SIZE","cache","cacheSize","withAlpha","length","output","slice","rgbaToLcha","lchaToRgba","fromString","s","hasOwnProperty","i","key","Error","c","isNaN","normalize","asArray","Array","isArray","r","g","b","a","undefined","Math","round","isStringColor","_"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/color.js"],"sourcesContent":["/**\n * @module ol/color\n */\nimport lchuv from 'color-space/lchuv.js';\nimport parseRgba from 'color-rgba';\nimport rgb from 'color-space/rgb.js';\nimport xyz from 'color-space/xyz.js';\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * @type {number}\n */\nconst MAX_CACHE_SIZE = 1024;\n\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\nconst cache = {};\n\n/**\n * @type {number}\n */\nlet cacheSize = 0;\n\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\nexport function rgbaToLcha(color) {\n  const output = xyz.lchuv(rgb.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\nexport function lchaToRgba(color) {\n  const output = xyz.rgb(lchuv.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport function fromString(s) {\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n\n  const color = parseRgba(s);\n  if (color.length !== 4) {\n    throw new Error('Failed to parse \"' + s + '\" as color');\n  }\n  for (const c of color) {\n    if (isNaN(c)) {\n      throw new Error('Failed to parse \"' + s + '\" as color');\n    }\n  }\n  normalize(color);\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * Exported for the tests.\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}