{"ast":null,"code":"/**\n * @module ol/expr/expression\n */\nimport { ascending } from '../array.js';\nimport { isStringColor } from '../color.js';\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   * `['resolution']` returns the current resolution\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` The current zoom level (WebGL only).\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size'\n};\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\n\nexport function typeName(type) {\n  const names = [];\n\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n\n  if (names.length === 0) {\n    return 'untyped';\n  }\n\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\n\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\n\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\n\nexport function isType(type, expected) {\n  return type === expected;\n}\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n\n}\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator) {\n    this.type = type;\n    this.operator = operator;\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    this.args = args;\n  }\n\n}\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\n\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n    style: {}\n  };\n}\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\n\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n\n    case 'color':\n      return ColorType;\n\n    case 'number':\n      return NumberType;\n\n    case 'boolean':\n      return BooleanType;\n\n    case 'number[]':\n      return NumberArrayType;\n\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\n\n\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean':\n      {\n        return new LiteralExpression(BooleanType, encoded);\n      }\n\n    case 'number':\n      {\n        return new LiteralExpression(typeHint === SizeType ? SizeType : NumberType, encoded);\n      }\n\n    case 'string':\n      {\n        let type = StringType;\n\n        if (isStringColor(encoded)) {\n          type |= ColorType;\n        } // apply the given type hint only if it won't result in an empty type\n\n\n        if (!isType(type & typeHint, NoneType)) {\n          type &= typeHint;\n        }\n\n        return new LiteralExpression(type, encoded);\n      }\n\n    default:\n      {// pass\n      }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n\n  if (encoded.length === 2) {\n    type |= SizeType;\n  } else if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n\n  if (typeHint) {\n    type &= typeHint;\n  }\n\n  return new LiteralExpression(type, encoded);\n}\n/**\n * @type {Object<string, string>}\n */\n\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string'\n};\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\n\nconst parsers = {\n  [Ops.Get]: createParser(_ref => {\n    let [_, typeHint] = _ref;\n\n    if (typeHint !== undefined) {\n      return getTypeFromHint(\n      /** @type {string} */\n\n      /** @type {LiteralExpression} */\n      typeHint.value);\n    }\n\n    return AnyType;\n  }, withArgsCount(1, 2), withGetArgs),\n  [Ops.Var]: createParser(_ref2 => {\n    let [firstArg] = _ref2;\n    return firstArg.type;\n  }, withArgsCount(1, 1), withVarArgs),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType)),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs, usesGeometryType),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),\n  [Ops.All]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),\n  [Ops.Not]: createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType)),\n  [Ops.Equal]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.NotEqual]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.GreaterThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.GreaterThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.LessThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.LessThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.Multiply]: createParser(parsedArgs => {\n    let outputType = NumberType | ColorType;\n\n    for (let i = 0; i < parsedArgs.length; i++) {\n      outputType &= parsedArgs[i].type;\n    }\n\n    return outputType;\n  }, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType),\n  [Ops.Coalesce]: createParser(parsedArgs => {\n    let type = AnyType;\n\n    for (let i = 1; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(2, Infinity), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.Divide]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Add]: createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType)),\n  [Ops.Subtract]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Clamp]: createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType)),\n  [Ops.Mod]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Pow]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Abs]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Floor]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Ceil]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Round]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Sin]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Cos]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Atan]: createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType)),\n  [Ops.Sqrt]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Match]: createParser(parsedArgs => {\n    let type = AnyType;\n\n    for (let i = 2; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs),\n  [Ops.Between]: createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType)),\n  [Ops.Interpolate]: createParser(parsedArgs => {\n    let type = ColorType | NumberType;\n\n    for (let i = 3; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n\n    return type;\n  }, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs),\n  [Ops.Case]: createParser(parsedArgs => {\n    let type = AnyType;\n\n    for (let i = 1; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),\n  [Ops.String]: createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),\n  [Ops.Array]: createParser(parsedArgs => {\n    return parsedArgs.length === 2 ? NumberArrayType | SizeType : parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;\n  }, withArgsCount(1, Infinity), parseArgsOfType(NumberType)),\n  [Ops.Color]: createParser(ColorType, withArgsCount(1, 4), parseArgsOfType(NumberType)),\n  [Ops.Band]: createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType)),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\n  [Ops.ToString]: createParser(StringType, withArgsCount(1, 1), parseArgsOfType(BooleanType | NumberType | StringType | ColorType))\n};\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\n\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n\n  context.properties.add(arg.value);\n\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n\n  return [arg];\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n\n  context.variables.add(varName);\n\n  if (!('variables' in context.style) || context.style.variables[varName] === undefined) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n\n  const initialValue = context.style.variables[varName];\n  const arg =\n  /** @type {LiteralExpression} */\n  parse(initialValue, context);\n  arg.value = varName;\n\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(`The variable ${varName} has type ${typeName(arg.type)} but the following type was expected: ${typeName(typeHint)}`);\n  }\n\n  return [arg];\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction usesGeometryType(encoded, context) {\n  context.geometryType = true;\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n\n  return [];\n}\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\n\n\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(`Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`);\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;\n      throw new Error(`Expected ${range} arguments for ${operation}, got ${argCount}`);\n    }\n  };\n}\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\n\n\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n\n    const args = new Array(argCount);\n\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(`Unexpected type for argument ${i} of ${operation} operation` + `, got ${gotType} but expected ${expectedType}`);\n      }\n\n      expression.type &= argType;\n      args[i] = expression;\n    }\n\n    return args;\n  };\n}\n/**\n * @type {ArgValidator}\n */\n\n\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1; // first pass to determine a narrowed down type\n\n  let sameType = AnyType;\n\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n\n  if (sameType === NoneType) {\n    throw new Error(`No common type could be found for arguments of ${operation} operation`);\n  } // re-parse args\n\n\n  const args = new Array(argCount);\n\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n\n  return args;\n}\n/**\n * @type {ArgValidator}\n */\n\n\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  if (argCount % 2 === 0) {\n    throw new Error(`An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);\n  }\n}\n/**\n * @type {ArgValidator}\n */\n\n\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  if (argCount % 2 === 1) {\n    throw new Error(`An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);\n  }\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type; // first parse args to figure out possible types\n\n  const args = new Array(argsCount - 2);\n\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  } // check input and output types validity\n\n\n  const expectedInputType = StringType | NumberType | BooleanType;\n\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(`Expected an input of type ${typeName(expectedInputType)} for the interpolate operation` + `, got ${typeName(inputType)} instead`);\n  }\n\n  inputType &= expectedInputType;\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(`Could not find a common output type for the following match operation: ` + JSON.stringify(encoded));\n  } // parse again inputs and outputs with common type\n\n\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  return [parse(encoded[1], context, inputType), ...args, parse(encoded[encoded.length - 1], context, outputType)];\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n\n    case 'exponential':\n      interpolation = interpolationType[1];\n\n      if (typeof interpolation !== 'number') {\n        throw new Error(`Expected a number base for exponential interpolation` + `, got ${JSON.stringify(interpolation)} instead`);\n      }\n\n      break;\n\n    default:\n      interpolation = null;\n  }\n\n  if (!interpolation) {\n    throw new Error(`Invalid interpolation type: ${JSON.stringify(interpolationType)}`);\n  }\n\n  interpolation = parse(interpolation, context); // check input types\n\n  let input = parse(encoded[2], context);\n\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(`Expected an input of type number for the interpolate operation` + `, got ${typeName(input.type)} instead`);\n  }\n\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(`Expected all stop input values in the interpolate operation to be of type number` + `, got ${typeName(stop.type)} at position ${i + 2} instead`);\n    }\n\n    let output = parse(encoded[i + 4], context);\n\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(`Expected all stop output values in the interpolate operation to be a number or color` + `, got ${typeName(output.type)} at position ${i + 3} instead`);\n    } // parse again with narrower types\n\n\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n\n  return [interpolation, input, ...args];\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context, typeHint);\n  let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type; // first parse args to figure out possible types\n\n  const args = new Array(encoded.length - 1);\n\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context, typeHint);\n\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(`Expected all conditions in the case operation to be of type boolean` + `, got ${typeName(condition.type)} at position ${i} instead`);\n    }\n\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(`Could not find a common output type for the following case operation: ` + JSON.stringify(encoded));\n  } // parse again args with common output type\n\n\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n\n  args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);\n  return args;\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack =\n  /** @type {any} */\n  encoded[2];\n\n  if (!Array.isArray(haystack)) {\n    throw new Error(`The \"in\" operator was provided a literal value which was not an array as second argument.`);\n  }\n\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(`For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`);\n    }\n\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(`The \"in\" operator was provided a literal value which was not an array as second argument.`);\n    }\n\n    haystack = haystack[1];\n  }\n\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n\n  if (isType(needleType, NoneType)) {\n    throw new Error(`Could not find a common type for the following in operation: ` + JSON.stringify(encoded));\n  }\n\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n/**\n * @type ArgValidator\n */\n\n\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n\n  if (index.type !== NumberType) {\n    throw new Error(`The first argument of palette must be an number, got ${typeName(index.type)} instead`);\n  }\n\n  const colors = encoded[2];\n\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n\n  const parsedColors = new Array(colors.length);\n\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(`The palette color at index ${i} must be a literal value`);\n    }\n\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(`The palette color at index ${i} should be of type color, got ${typeName(color.type)} instead`);\n    }\n\n    parsedColors[i] = color;\n  }\n\n  return [index, ...parsedColors];\n}\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\n\n\nfunction createParser(returnType) {\n  for (var _len2 = arguments.length, argValidators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    argValidators[_key2 - 1] = arguments[_key2];\n  }\n\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n\n    let actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(`The following expression was expected to return ${typeName(typeHint)}, but returns ${typeName(actualType)} instead: ${JSON.stringify(encoded)}`);\n      }\n\n      actualType &= typeHint;\n    }\n\n    if (actualType === NoneType) {\n      throw new Error(`No matching type was found for the following expression: ${JSON.stringify(encoded)}`);\n    }\n\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\n\n\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n  const parser = parsers[operator];\n\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n\n  return parser(encoded, context, typeHint);\n}\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\n\n\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n\n  const type = geometry.getType();\n\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return (\n        /** @type {'Point'|'LineString'|'Polygon'} */\n        type.substring(5)\n      );\n\n    case 'Circle':\n      return 'Polygon';\n\n    case 'GeometryCollection':\n      return computeGeometryType(\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */\n      geometry.getGeometries()[0]);\n\n    default:\n      return '';\n  }\n}","map":{"version":3,"names":["ascending","isStringColor","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","SizeType","AnyType","Math","pow","typeNames","namedTypes","Object","keys","map","Number","sort","typeName","type","names","namedType","includesType","push","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","constructor","value","CallExpression","operator","args","newParsingContext","variables","Set","properties","featureId","geometryType","style","getTypeFromHint","typeHint","Error","parse","encoded","context","Array","isArray","parseCallExpression","item","Ops","Get","Var","Concat","GeometryType","Any","All","Not","Resolution","Zoom","Time","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","Between","Interpolate","Coalesce","Case","In","String","Color","Id","Band","Palette","ToString","parsers","createParser","_","undefined","withArgsCount","withGetArgs","firstArg","withVarArgs","withNoArgs","usesFeatureId","Infinity","parseArgsOfType","usesGeometryType","narrowArgsType","parsedArgs","outputType","i","withEvenArgs","parseMatchArgs","parseInterpolateArgs","withOddArgs","parseCaseArgs","parseInArgs","parsePaletteArgs","arg","add","hint","varName","initialValue","operation","minArgs","maxArgs","argCount","plural","range","argType","expression","gotType","expectedType","sameType","JSON","stringify","argsCount","input","inputType","fallback","match","output","expectedInputType","interpolationType","interpolation","stop","condition","haystack","needleType","needle","index","colors","parsedColors","color","returnType","argValidators","actualType","parser","computeGeometryType","geometry","getType","substring","getGeometries"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {isStringColor} from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   * `['resolution']` returns the current resolution\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` The current zoom level (WebGL only).\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n    style: {},\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      return new LiteralExpression(\n        typeHint === SizeType ? SizeType : NumberType,\n        encoded,\n      );\n    }\n    case 'string': {\n      let type = StringType;\n      if (isStringColor(encoded)) {\n        type |= ColorType;\n      }\n      // apply the given type hint only if it won't result in an empty type\n      if (!isType(type & typeHint, NoneType)) {\n        type &= typeHint;\n      }\n      return new LiteralExpression(type, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n  if (encoded.length === 2) {\n    type |= SizeType;\n  } else if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string',\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(\n    ([_, typeHint]) => {\n      if (typeHint !== undefined) {\n        return getTypeFromHint(\n          /** @type {string} */ (\n            /** @type {LiteralExpression} */ (typeHint).value\n          ),\n        );\n      }\n      return AnyType;\n    },\n    withArgsCount(1, 2),\n    withGetArgs,\n  ),\n  [Ops.Var]: createParser(\n    ([firstArg]) => firstArg.type,\n    withArgsCount(1, 1),\n    withVarArgs,\n  ),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(\n    StringType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(AnyType),\n  ),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs, usesGeometryType),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType),\n  ),\n  [Ops.All]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType),\n  ),\n  [Ops.Not]: createParser(\n    BooleanType,\n    withArgsCount(1, 1),\n    parseArgsOfType(BooleanType),\n  ),\n  [Ops.Equal]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.NotEqual]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.GreaterThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.GreaterThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.LessThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.LessThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.Multiply]: createParser(\n    (parsedArgs) => {\n      let outputType = NumberType | ColorType;\n      for (let i = 0; i < parsedArgs.length; i++) {\n        outputType &= parsedArgs[i].type;\n      }\n      return outputType;\n    },\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType | ColorType),\n    narrowArgsType,\n  ),\n  [Ops.Coalesce]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 1; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(2, Infinity),\n    parseArgsOfType(AnyType),\n    narrowArgsType,\n  ),\n  [Ops.Divide]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Add]: createParser(\n    NumberType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Subtract]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Clamp]: createParser(\n    NumberType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Mod]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Pow]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Abs]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Floor]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Ceil]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Round]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Sin]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Cos]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Atan]: createParser(\n    NumberType,\n    withArgsCount(1, 2),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Sqrt]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Match]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 2; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(4, Infinity),\n    withEvenArgs,\n    parseMatchArgs,\n  ),\n  [Ops.Between]: createParser(\n    BooleanType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Interpolate]: createParser(\n    (parsedArgs) => {\n      let type = ColorType | NumberType;\n      for (let i = 3; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      return type;\n    },\n    withArgsCount(6, Infinity),\n    withEvenArgs,\n    parseInterpolateArgs,\n  ),\n  [Ops.Case]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 1; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(3, Infinity),\n    withOddArgs,\n    parseCaseArgs,\n  ),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(\n    NumberType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType),\n  ),\n  [Ops.String]: createParser(\n    StringType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType),\n  ),\n  [Ops.Array]: createParser(\n    (parsedArgs) => {\n      return parsedArgs.length === 2\n        ? NumberArrayType | SizeType\n        : parsedArgs.length === 3 || parsedArgs.length === 4\n          ? NumberArrayType | ColorType\n          : NumberArrayType;\n    },\n    withArgsCount(1, Infinity),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Color]: createParser(\n    ColorType,\n    withArgsCount(1, 4),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Band]: createParser(\n    NumberType,\n    withArgsCount(1, 3),\n    parseArgsOfType(NumberType),\n  ),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\n  [Ops.ToString]: createParser(\n    StringType,\n    withArgsCount(1, 1),\n    parseArgsOfType(BooleanType | NumberType | StringType | ColorType),\n  ),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (\n    !('variables' in context.style) ||\n    context.style.variables[varName] === undefined\n  ) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */ (parse(initialValue, context));\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\n      `The variable ${varName} has type ${typeName(\n        arg.type,\n      )} but the following type was expected: ${typeName(typeHint)}`,\n    );\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesGeometryType(encoded, context) {\n  context.geometryType = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `Expected ${range} arguments for ${operation}, got ${argCount}`,\n      );\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\n          `Unexpected type for argument ${i} of ${operation} operation` +\n            `, got ${gotType} but expected ${expectedType}`,\n        );\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n\n  if (sameType === NoneType) {\n    throw new Error(\n      `No common type could be found for arguments of ${operation} operation`,\n    );\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount,\n      )} instead`,\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount,\n      )} instead`,\n    );\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\n      `Expected an input of type ${typeName(\n        expectedInputType,\n      )} for the interpolate operation` +\n        `, got ${typeName(inputType)} instead`,\n    );\n  }\n  inputType &= expectedInputType;\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following match operation: ` +\n        JSON.stringify(encoded),\n    );\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  return [\n    parse(encoded[1], context, inputType),\n    ...args,\n    parse(encoded[encoded.length - 1], context, outputType),\n  ];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\n          `Expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(interpolation)} instead`,\n        );\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\n      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`,\n    );\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\n      `Expected an input of type number for the interpolate operation` +\n        `, got ${typeName(input.type)} instead`,\n    );\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\n        `Expected all stop input values in the interpolate operation to be of type number` +\n          `, got ${typeName(stop.type)} at position ${i + 2} instead`,\n      );\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\n        `Expected all stop output values in the interpolate operation to be a number or color` +\n          `, got ${typeName(output.type)} at position ${i + 3} instead`,\n      );\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context, typeHint);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context, typeHint);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\n        `Expected all conditions in the case operation to be of type boolean` +\n          `, got ${typeName(condition.type)} at position ${i} instead`,\n      );\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following case operation: ` +\n        JSON.stringify(encoded),\n    );\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(\n    encoded[encoded.length - 1],\n    context,\n    outputType,\n  );\n\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */ (encoded[2]);\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `The \"in\" operator was provided a literal value which was not an array as second argument.`,\n    );\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`,\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `The \"in\" operator was provided a literal value which was not an array as second argument.`,\n      );\n    }\n    haystack = haystack[1];\n  }\n\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\n      `Could not find a common type for the following in operation: ` +\n        JSON.stringify(encoded),\n    );\n  }\n\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\n      `The first argument of palette must be an number, got ${typeName(\n        index.type,\n      )} instead`,\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `The palette color at index ${i} must be a literal value`,\n      );\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\n        `The palette color at index ${i} should be of type color, got ${typeName(\n          color.type,\n        )} instead`,\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType, ...argValidators) {\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs =\n        argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType =\n      typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\n          `The following expression was expected to return ${typeName(\n            typeHint,\n          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(\n            encoded,\n          )}`,\n        );\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\n        `No matching type was found for the following expression: ${JSON.stringify(\n          encoded,\n        )}`,\n      );\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context, typeHint);\n}\n\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n  const type = geometry.getType();\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\n    case 'Circle':\n      return 'Polygon';\n    case 'GeometryCollection':\n      return computeGeometryType(\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries()[0],\n      );\n    default:\n      return '';\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,SAAR,QAAwB,aAAxB;AACA,SAAQC,aAAR,QAA4B,aAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAf;AACA,OAAO,MAAMC,QAAQ,GAAG,CAAjB;AACP,OAAO,MAAMC,WAAW,GAAG,KAAKF,QAAQ,EAAjC;AACP,OAAO,MAAMG,UAAU,GAAG,KAAKH,QAAQ,EAAhC;AACP,OAAO,MAAMI,UAAU,GAAG,KAAKJ,QAAQ,EAAhC;AACP,OAAO,MAAMK,SAAS,GAAG,KAAKL,QAAQ,EAA/B;AACP,OAAO,MAAMM,eAAe,GAAG,KAAKN,QAAQ,EAArC;AACP,OAAO,MAAMO,QAAQ,GAAG,KAAKP,QAAQ,EAA9B;AACP,OAAO,MAAMQ,OAAO,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYV,QAAZ,IAAwB,CAAxC;AAEP,MAAMW,SAAS,GAAG;EAChB,CAACT,WAAD,GAAe,SADC;EAEhB,CAACC,UAAD,GAAc,QAFE;EAGhB,CAACC,UAAD,GAAc,QAHE;EAIhB,CAACC,SAAD,GAAa,OAJG;E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"},"metadata":{},"sourceType":"module"}