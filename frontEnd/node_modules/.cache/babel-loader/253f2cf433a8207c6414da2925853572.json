{"ast":null,"code":"/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport { LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight } from '../extent.js';\nimport { douglasPeucker, douglasPeuckerArray, quantizeArray } from '../geom/flat/simplify.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { get as getProjection } from '../proj.js';\nimport { inflateEnds } from '../geom/flat/orient.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from '../geom/flat/transform.js';\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\n\nconst tmpTransform = createTransform();\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\n\nclass RenderFeature {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, stride, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n\n    this.extent_;\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n\n    this.id_ = id;\n    /**\n     * @private\n     * @type {Type}\n     */\n\n    this.type_ = type;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatCoordinates_ = flatCoordinates;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatMidpoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n\n    this.ends_ = ends || null;\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n\n    this.properties_ = properties;\n    /**\n     * @type {number}\n     */\n\n    this.squaredTolerance_;\n    /**\n     * @type {number}\n     */\n\n    this.stride_ = stride;\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n\n    this.simplifiedGeometry_;\n  }\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n\n\n  get(key) {\n    return this.properties_[key];\n  }\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n\n\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === 'Point' ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n\n    return this.extent_;\n  }\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);\n    }\n\n    return this.flatInteriorPoints_;\n  }\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const ends = inflateEnds(this.flatCoordinates_, this.ends_);\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, ends, 2, flatCenters);\n    }\n\n    return this.flatInteriorPoints_;\n  }\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n\n\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n\n    return this.flatMidpoints_;\n  }\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n\n\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends =\n      /** @type {Array<number>} */\n      this.ends_;\n\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n\n    return this.flatMidpoints_;\n  }\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n\n\n  getId() {\n    return this.id_;\n  }\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n\n\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n\n\n  getGeometry() {\n    return this;\n  }\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n\n\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n\n\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n\n\n  getProperties() {\n    return this.properties_;\n  }\n  /**\n   * Get an object of all property names and values.  This has the same behavior as getProperties,\n   * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n   * @return {Object<string, *>?} Object.\n   */\n\n\n  getPropertiesInternal() {\n    return this.properties_;\n  }\n  /**\n   * @return {number} Stride.\n   */\n\n\n  getStride() {\n    return this.stride_;\n  }\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n\n\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n  /**\n   * Get the type of this feature's geometry.\n   * @return {Type} Geometry type.\n   * @api\n   */\n\n\n  getType() {\n    return this.type_;\n  }\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n\n\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n    }\n  }\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   */\n\n\n  applyTransform(transformFn) {\n    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n  }\n  /**\n   * @return {RenderFeature} A cloned render feature.\n   */\n\n\n  clone() {\n    return new RenderFeature(this.type_, this.flatCoordinates_.slice(), this.ends_?.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);\n  }\n  /**\n   * @return {Array<number>|null} Ends.\n   */\n\n\n  getEnds() {\n    return this.ends_;\n  }\n  /**\n   * Add transform and resolution based geometry simplification to this instance.\n   * @return {RenderFeature} This render feature.\n   */\n\n\n  enableSimplifyTransformed() {\n    this.simplifyTransformed = memoizeOne((squaredTolerance, transform) => {\n      if (squaredTolerance === this.squaredTolerance_) {\n        return this.simplifiedGeometry_;\n      }\n\n      this.simplifiedGeometry_ = this.clone();\n\n      if (transform) {\n        this.simplifiedGeometry_.applyTransform(transform);\n      }\n\n      const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();\n      let simplifiedEnds;\n\n      switch (this.type_) {\n        case 'LineString':\n          simplifiedFlatCoordinates.length = douglasPeucker(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.flatCoordinates_.length, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0);\n          simplifiedEnds = [simplifiedFlatCoordinates.length];\n          break;\n\n        case 'MultiLineString':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = douglasPeuckerArray(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n          break;\n\n        case 'Polygon':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = quantizeArray(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n          break;\n\n        default:\n      }\n\n      if (simplifiedEnds) {\n        this.simplifiedGeometry_ = new RenderFeature(this.type_, simplifiedFlatCoordinates, simplifiedEnds, 2, this.properties_, this.id_);\n      }\n\n      this.squaredTolerance_ = squaredTolerance;\n      return this.simplifiedGeometry_;\n    });\n    return this;\n  }\n\n}\n/**\n * @return {Array<number>} Flat coordinates.\n */\n\n\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\n\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n\n    case 'MultiLineString':\n      return new MultiLineString(renderFeature.getFlatCoordinates(), 'XY',\n      /** @type {Array<number>} */\n      renderFeature.getEnds());\n\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1 ? new MultiPolygon(flatCoordinates, 'XY', endss) : new Polygon(flatCoordinates, 'XY', ends);\n\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\n\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n\n  feature.setGeometry(geometry);\n\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n\n  feature.setProperties(properties, true);\n  return feature;\n}\nexport default RenderFeature;","map":{"version":3,"names":["Feature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","compose","composeTransform","create","createTransform","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","getCenter","getHeight","douglasPeucker","douglasPeuckerArray","quantizeArray","extend","getInteriorPointOfArray","getInteriorPointsOfMultiArray","get","getProjection","inflateEnds","interpolatePoint","linearRingss","linearRingssCenter","memoizeOne","transform2D","tmpTransform","RenderFeature","constructor","type","flatCoordinates","ends","stride","properties","id","styleFunction","extent_","id_","type_","flatCoordinates_","flatInteriorPoints_","flatMidpoints_","ends_","properties_","squaredTolerance_","stride_","simplifiedGeometry_","key","getExtent","length","getFlatInteriorPoint","flatCenter","getFlatInteriorPoints","flatCenters","getFlatMidpoint","getFlatMidpoints","offset","i","ii","end","midpoint","getId","getOrientedFlatCoordinates","getGeometry","getSimplifiedGeometry","squaredTolerance","simplifyTransformed","transform","getProperties","getPropertiesInternal","getStride","getStyleFunction","getType","projection","pixelExtent","projectedExtent","getWorldExtent","scale","applyTransform","transformFn","clone","slice","Object","assign","getEnds","enableSimplifyTransformed","simplifiedFlatCoordinates","getFlatCoordinates","simplifiedEnds","Math","sqrt","prototype","toGeometry","renderFeature","geometryType","endss","Error","toFeature","geometryName","geometry","feature","undefined","setGeometryName","setGeometry","setId","setProperties"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/render/Feature.js"],"sourcesContent":["/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromFlatCoordinates,\n  getCenter,\n  getHeight,\n} from '../extent.js';\nimport {\n  douglasPeucker,\n  douglasPeuckerArray,\n  quantizeArray,\n} from '../geom/flat/simplify.js';\nimport {extend} from '../array.js';\nimport {\n  getInteriorPointOfArray,\n  getInteriorPointsOfMultiArray,\n} from '../geom/flat/interiorpoint.js';\nimport {get as getProjection} from '../proj.js';\nimport {inflateEnds} from '../geom/flat/orient.js';\nimport {interpolatePoint} from '../geom/flat/interpolate.js';\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from '../geom/flat/transform.js';\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, stride, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.ends_ = ends || null;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n\n    /**\n     * @type {number}\n     */\n    this.squaredTolerance_;\n\n    /**\n     * @type {number}\n     */\n    this.stride_ = stride;\n\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n    this.simplifiedGeometry_;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ =\n        this.type_ === 'Point'\n          ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n          : createOrUpdateFromFlatCoordinates(\n              this.flatCoordinates_,\n              0,\n              this.flatCoordinates_.length,\n              2,\n            );\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(\n        this.flatCoordinates_,\n        0,\n        this.ends_,\n        2,\n        flatCenter,\n        0,\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const ends = inflateEnds(this.flatCoordinates_, this.ends_);\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.flatCoordinates_,\n        0,\n        ends,\n        2,\n        flatCenters,\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        0.5,\n      );\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */ (this.ends_);\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * Get an object of all property names and values.  This has the same behavior as getProperties,\n   * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride_;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(\n        tmpTransform,\n        projectedExtent[0],\n        projectedExtent[3],\n        scale,\n        -scale,\n        0,\n        0,\n        0,\n      );\n      transform2D(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        tmpTransform,\n        this.flatCoordinates_,\n      );\n    }\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   */\n  applyTransform(transformFn) {\n    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n  }\n\n  /**\n   * @return {RenderFeature} A cloned render feature.\n   */\n  clone() {\n    return new RenderFeature(\n      this.type_,\n      this.flatCoordinates_.slice(),\n      this.ends_?.slice(),\n      this.stride_,\n      Object.assign({}, this.properties_),\n      this.id_,\n    );\n  }\n\n  /**\n   * @return {Array<number>|null} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Add transform and resolution based geometry simplification to this instance.\n   * @return {RenderFeature} This render feature.\n   */\n  enableSimplifyTransformed() {\n    this.simplifyTransformed = memoizeOne((squaredTolerance, transform) => {\n      if (squaredTolerance === this.squaredTolerance_) {\n        return this.simplifiedGeometry_;\n      }\n      this.simplifiedGeometry_ = this.clone();\n      if (transform) {\n        this.simplifiedGeometry_.applyTransform(transform);\n      }\n      const simplifiedFlatCoordinates =\n        this.simplifiedGeometry_.getFlatCoordinates();\n      let simplifiedEnds;\n      switch (this.type_) {\n        case 'LineString':\n          simplifiedFlatCoordinates.length = douglasPeucker(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.flatCoordinates_.length,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n          );\n          simplifiedEnds = [simplifiedFlatCoordinates.length];\n          break;\n        case 'MultiLineString':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = douglasPeuckerArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds,\n          );\n          break;\n        case 'Polygon':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = quantizeArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            Math.sqrt(squaredTolerance),\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds,\n          );\n          break;\n        default:\n      }\n      if (simplifiedEnds) {\n        this.simplifiedGeometry_ = new RenderFeature(\n          this.type_,\n          simplifiedFlatCoordinates,\n          simplifiedEnds,\n          2,\n          this.properties_,\n          this.id_,\n        );\n      }\n      this.squaredTolerance_ = squaredTolerance;\n      return this.simplifiedGeometry_;\n    });\n    return this;\n  }\n}\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n  RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(\n        renderFeature.getFlatCoordinates(),\n        'XY',\n        /** @type {Array<number>} */ (renderFeature.getEnds()),\n      );\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1\n        ? new MultiPolygon(flatCoordinates, 'XY', endss)\n        : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\n\nexport default RenderFeature;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}