{"ast":null,"code":"/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle, defaultLineDash, defaultLineDashOffset } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\n\nclass CanvasPolygonBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle !== undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    return offset;\n  }\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n\n\n  drawCircle(circleGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature, index);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset]);\n    }\n\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    this.endGeometry(feature);\n  }\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n\n\n  drawPolygon(polygonGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature, index);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset]);\n    }\n\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0,\n    /** @type {Array<number>} */\n    ends, stride);\n    this.endGeometry(feature);\n  }\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n\n\n  drawMultiPolygon(multiPolygonGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature, index);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset]);\n    }\n\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(feature);\n  }\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    const tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n\n    return super.finish();\n  }\n  /**\n   * @private\n   */\n\n\n  setFillStrokeStyles_() {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n\n}\n\nexport default CanvasPolygonBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","beginPathInstruction","closePathInstruction","fillInstruction","strokeInstruction","defaultFillStyle","defaultLineDash","defaultLineDashOffset","snap","CanvasPolygonBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatLineCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","drawCircle","circleGeometry","feature","index","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","updateFillStyle","createFill","updateStrokeStyle","applyStroke"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/render/canvas/PolygonBuilder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, {\n  beginPathInstruction,\n  closePathInstruction,\n  fillInstruction,\n  strokeInstruction,\n} from './Instruction.js';\nimport {\n  defaultFillStyle,\n  defaultLineDash,\n  defaultLineDashOffset,\n} from '../canvas.js';\nimport {snap} from '../../geom/flat/simplify.js';\n\nclass CanvasPolygonBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle !== undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatLineCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        true,\n        !stroke,\n      );\n      const moveToLineToInstruction = [\n        CanvasInstruction.MOVE_TO_LINE_TO,\n        myBegin,\n        myEnd,\n      ];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n  drawCircle(circleGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature, index);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        defaultLineDash,\n        defaultLineDashOffset,\n      ]);\n    }\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(\n      flatCoordinates,\n      0,\n      flatCoordinates.length,\n      stride,\n      false,\n      false,\n    );\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n  drawPolygon(polygonGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature, index);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        defaultLineDash,\n        defaultLineDashOffset,\n      ]);\n    }\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(\n      flatCoordinates,\n      0,\n      /** @type {Array<number>} */ (ends),\n      stride,\n    );\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} [index] Render order index.\n   */\n  drawMultiPolygon(multiPolygonGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature, index);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        defaultLineDash,\n        defaultLineDashOffset,\n      ]);\n    }\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(\n        flatCoordinates,\n        offset,\n        endss[i],\n        stride,\n      );\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    const tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n    return super.finish();\n  }\n\n  /**\n   * @private\n   */\n  setFillStrokeStyles_() {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n}\n\nexport default CanvasPolygonBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}