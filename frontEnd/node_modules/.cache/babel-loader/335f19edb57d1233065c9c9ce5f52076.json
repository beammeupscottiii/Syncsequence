{"ast":null,"code":"/**\n * @module ol/geom/MultiPolygon\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\n\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n\n    this.endss_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.flatInteriorPointsRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n\n    this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons =\n      /** @type {Array<Polygon>} */\n      coordinates;\n      /** @type {Array<number>} */\n\n      const flatCoordinates = [];\n      const thisEndss = [];\n\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n\n      layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(layout,\n      /** @type {Array<number>} */\n      coordinates);\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n      /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */\n      coordinates, layout);\n    }\n  }\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n\n\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n\n    this.endss_.push(ends);\n    this.changed();\n  }\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n\n\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n    multiPolygon.applyProperties(this);\n    return multiPolygon;\n  }\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  }\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n\n\n  containsXY(x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  }\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  getArea() {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  }\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n\n\n  getCoordinates(right) {\n    let flatCoordinates;\n\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  }\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n\n\n  getEndss() {\n    return this.endss_;\n  }\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n\n    return (\n      /** @type {Array<number>} */\n      this.flatInteriorPoints_\n    );\n  }\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n\n\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n\n\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n\n      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n\n      this.orientedRevision_ = this.getRevision();\n    }\n\n    return (\n      /** @type {Array<number>} */\n      this.orientedFlatCoordinates_\n    );\n  }\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n\n\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n\n\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n\n    let offset;\n\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  }\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n\n\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n\n      const polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n\n    return polygons;\n  }\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n\n\n  getType() {\n    return 'MultiPolygon';\n  }\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n\n\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  }\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n\n\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    const endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n\n    this.changed();\n  }\n\n}\n\nexport default MultiPolygon;","map":{"version":3,"names":["MultiPoint","Polygon","SimpleGeometry","assignClosestMultiArrayPoint","multiArrayMaxSquaredDelta","closestSquaredDistanceXY","deflateMultiCoordinatesArray","extend","getInteriorPointsOfMultiArray","inflateMultiCoordinatesArray","intersectsLinearRingMultiArray","linearRingssAreOriented","orientLinearRingsArray","linearRingss","linearRingssArea","linearRingssCenter","linearRingssContainsXY","quantizeMultiArray","MultiPolygon","constructor","coordinates","layout","endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","Array","isArray","polygons","flatCoordinates","thisEndss","i","ii","length","polygon","offset","ends","getEnds","j","jj","getFlatCoordinates","push","getLayout","undefined","setFlatCoordinates","setCoordinates","appendPolygon","slice","changed","clone","len","newEndss","multiPolygon","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getOrientedFlatCoordinates","containsXY","getArea","getCoordinates","right","getEndss","getFlatInteriorPoints","flatCenters","getInteriorPoints","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","getPolygon","index","prevEnds","end","getPolygons","getType","intersectsExtent","extent","setLayout","lastEnds"],"sources":["/home/jce/Web Dev Space/Syncsequence/frontEnd/node_modules/ol/geom/MultiPolygon.js"],"sourcesContent":["/**\n * @module ol/geom/MultiPolygon\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout =\n        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss,\n    );\n    multiPolygon.applyProperties(this);\n\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y,\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        right,\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters,\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatInteriorPoints_);\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride,\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss,\n    );\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends,\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends,\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_,\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}